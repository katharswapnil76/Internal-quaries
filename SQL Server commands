## SQL Server Performance Tuning :
---------------------------------
Step 1 → Are we CPU, Memory, I/O, or Locking bound?
Use:

Wait Stats
sys.dm_exec_requests
Performance Insights graphs

Step 2 → Identify top queries causing load
Use:

Top CPU
Top IO
Long running queries

Step 3 → Check for blocking & lock chains
Use:

Blocking queries
sys.dm_tran_locks

Step 4 → Check execution plans
Look for:

Missing indexes
Bad estimates
Key lookups
Scan vs Seek

Step 5 → Check storage IOPS in RDS
Use AWS console and queries for I/O waits:

PAGEIOLATCH
WRITELOG

Step 6 → Tune indexes, stats, queries

Create missing indexes
Update statistics
Reduce parallelism if needed

---  Which application or node is generating the most workload? (Grouped by application node and database and status)
SELECT
    s.program_name AS application_name,
    DB_NAME(r.database_id) AS database_name,
    r.status,
    COUNT(*) AS total_requests,
    SUM(r.cpu_time) AS total_cpu_ms,
    SUM(r.total_elapsed_time) AS total_elapsed_ms
FROM sys.dm_exec_sessions s
JOIN sys.dm_exec_requests r 
    ON s.session_id = r.session_id
GROUP BY s.program_name, DB_NAME(r.database_id), r.status
ORDER BY total_requests DESC;

---  what is running right now in your AWS RDS SQL Server instance
SELECT
      s.session_id,
      r.request_id,
      s.login_name,
      s.host_name,
      s.program_name AS application_name,
      DB_NAME(r.database_id) AS database_name,
      r.status,
      r.command,
      r.cpu_time,
      r.total_elapsed_time,
      r.wait_type,
      r.wait_time,
      r.wait_resource,
      r.blocking_session_id,
      r.reads, r.writes,
      r.logical_reads,
      SUBSTRING(t.text, (r.statement_start_offset/2)+1,
        ((CASE r.statement_end_offset 
             WHEN -1 THEN DATALENGTH(t.text)
             ELSE r.statement_end_offset 
         END - r.statement_start_offset)/2) + 1) AS running_statement,
      t.text AS full_query_text
FROM sys.dm_exec_sessions s
JOIN sys.dm_exec_requests r
      ON s.session_id = r.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
ORDER BY r.total_elapsed_time DESC;

--- See All Running / Waiting Queries With Waits
SELECT
    r.session_id,
    s.login_name,
    s.host_name,
    s.program_name,
    DB_NAME(r.database_id) AS database_name,
    r.status,
    r.command,
    r.wait_type,
    r.wait_time,
    r.wait_resource,
    r.cpu_time,
    r.total_elapsed_time,
    t.text AS query_text
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
ORDER BY r.wait_time DESC;

--- Identify Blocking Chains
SELECT
    r.session_id AS blocked_session,
    r.blocking_session_id AS blocker_session,
    DB_NAME(r.database_id) AS database_name,
    r.status,
    r.wait_type,
    r.wait_time,
    r.wait_resource,
    t.text AS blocked_query,
    bt.text AS blocking_query
FROM sys.dm_exec_requests r
LEFT JOIN sys.dm_exec_requests br 
        ON r.blocking_session_id = br.session_id
OUTER APPLY sys.dm_exec_sql_text(r.sql_handle) t
OUTER APPLY sys.dm_exec_sql_text(br.sql_handle) bt
WHERE r.blocking_session_id <> 0;

--- Check Current CPU Consumer : 
SELECT TOP 20
    s.session_id,
    s.login_name,
    s.host_name,
    s.program_name,
    r.cpu_time,
    r.total_elapsed_time,
    t.text AS query_text
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
ORDER BY r.cpu_time DESC;

--- High I/O Queries
SELECT TOP 20
    r.session_id,
    DB_NAME(r.database_id) AS database_name,
    r.reads, r.writes,
    r.logical_reads,
    r.wait_type,
    r.wait_time,
    t.text AS query_text
FROM sys.dm_exec_requests r
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
ORDER BY r.reads + r.writes DESC;

--- Checking Memory usage 
SELECT
    type,
    SUM(pages_kb)/1024 AS MB_used
FROM sys.dm_os_memory_clerks
GROUP BY type
ORDER BY MB_used DESC;

--- Check Top Queries Waiting for Memory Grants
SELECT
    r.session_id,
    r.request_id,
    r.granted_query_memory,
    r.wait_type,
    r.wait_resource,
    t.text
FROM sys.dm_exec_requests r
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
WHERE r.wait_type LIKE '%MEMORY%';

--- Index Fragmentation
SELECT
    DB_NAME(database_id) AS database_name,
    OBJECT_NAME(object_id) AS table_name,
    index_id,
    avg_fragmentation_in_percent
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED')
WHERE avg_fragmentation_in_percent > 30
ORDER BY avg_fragmentation_in_percent DESC;

--- Missing Indexes (Top Recommendations)
SELECT TOP 20
    migs.user_seeks,
    migs.user_scans,
    mid.statement AS table_name,
    mid.equality_columns,
    mid.inequality_columns,
    mid.included_columns
FROM sys.dm_db_missing_index_details mid
JOIN sys.dm_db_missing_index_groups mig 
        ON mid.index_handle = mig.index_handle
JOIN sys.dm_db_missing_index_group_stats migs 
        ON mig.index_group_handle = migs.group_handle
ORDER BY migs.user_seeks DESC;


## Backup and Restore on RDS:
-----------------------------
--- create full backup
exec msdb.dbo.rds_backup_database
	@source_db_name='AdventureWorks2014',
	@s3_arn_to_backup_to='arn:aws:s3:::rds-course-backups/AdventureWorks2014.bak',		
	@overwrite_s3_backup_file=1,
	@type='FULL',
	@number_of_files=1;

--track backup task
exec msdb.dbo.rds_task_status @db_name='AdventureWorks20141', @task_id=3;

--- create differential backup
exec msdb.dbo.rds_backup_database
	@source_db_name='AdventureWorks2014',
	@s3_arn_to_backup_to='arn:aws:s3:::rds-course-backups/AdventureWorks2014_diff.bak',		
	@overwrite_s3_backup_file=1,
	@type='DIFFERENTIAL',
	@number_of_files=1;

--Restore full backup
exec msdb.dbo.rds_restore_database
	@restore_db_name='AdventureWorks20141',
	@s3_arn_to_restore_from='arn:aws:s3:::rds-course-backups/AdventureWorks2014.bak',
	@with_norecovery=0,	
	@type='FULL';

--Restore full backup with mulitple files
exec msdb.dbo.rds_restore_database
	@restore_db_name='AdventureWorks20141',
	@s3_arn_to_restore_from='arn:aws:s3:::rds-course-backups/AdventureWorks2014*',
	@with_norecovery=0,	
	@type='FULL';

-- Restore differential
exec msdb.dbo.rds_restore_database
	@restore_db_name='AdventureWorks20141',
	@s3_arn_to_restore_from='arn:aws:s3:::rds-course-backups/AdventureWorks2014_diff.bak',	
	@with_norecovery=0,
	@type='DIFFERENTIAL';

################################################################################################
## To check which are the existing login disabled in the server :
-------------------------------------------------------------
select sp.name from sys.server_principals sp where sp.type IN ('S','U') AND sp.name NOT LIKE '##%' AND sp.name NOT LIKE 'NT %' AND sp.name NOT IN ('sa') AND sp.is_disabled = 1;

## To get the create statement for the create user :
-------------------------------------------------
SELECT 'CREATE LOGIN [' + sp.name + '] ' + 'WITH PASSWORD = ''@cT1m1ze@Dm1n1str4t0r'' , CHECK_POLICY = OFF;' FROM sys.server_principals sp WHERE sp.type IN ('S','U') AND sp.name NOT LIKE '##%' AND sp.name NOT LIKE 'NT %' AND sp.name NOT IN ('sa');

## Get the list of all the orphans users and their list :
--------------------------------------------------------
--- Checking for the orphans users in one perticular database : 

SELECT dp.name AS UserName
FROM sys.database_principals dp
LEFT JOIN sys.server_principals sp ON dp.sid = sp.sid
WHERE dp.type = 'S'
  AND dp.authentication_type = 1
  AND sp.sid IS NULL;

--- Below we can check in the master database and will give for all the database it will check for the sql server user as well as window group user:

DECLARE @db SYSNAME;
DECLARE @sql NVARCHAR(MAX);

DECLARE db_cursor CURSOR FOR
SELECT name
FROM sys.databases
WHERE name NOT IN ('master','model','msdb','tempdb');

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @db;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @sql = '
USE [' + @db + '];

SELECT
    ''-- Database: ' + @db + ''' AS Output
UNION ALL
SELECT
    ''ALTER USER ['' + dp.name + ''] WITH LOGIN = ['' + dp.name + ''];''
FROM sys.database_principals dp
LEFT JOIN sys.server_principals sp
       ON dp.sid = sp.sid
WHERE sp.sid IS NULL
  AND dp.type IN (''S'',''U'')
  AND dp.name NOT IN (''dbo'',''guest'',''sys'',''INFORMATION_SCHEMA'');
';

    PRINT '------------------------------------------------------------';
    PRINT 'Database: ' + @db;
    PRINT '------------------------------------------------------------';

    EXEC (@sql);

    FETCH NEXT FROM db_cursor INTO @db;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;

--- Below query will help to determine the windowsgroup login orphans users in database :

SELECT dp.name AS DBUser, dp.type_desc, dp.sid
FROM sys.database_principals dp
LEFT JOIN sys.server_principals sp ON dp.sid = sp.sid
WHERE dp.type = 'G'    -- Windows groups
  AND sp.sid IS NULL
  AND dp.name NOT IN ('dbo','guest','sys','INFORMATION_SCHEMA');

--- How to fix the windows group orphans users in the database : 

Case A — The group exists in AD
		CREATE LOGIN [DOMAIN\YourGroup] FROM WINDOWS;
Then map it =>
		USE YourDatabase;
		ALTER USER [DOMAIN\YourGroup] WITH LOGIN = [DOMAIN\YourGroup];

Case B — Domain changed (Example: OLD-DOMAIN\AML_Group → NEW-DOMAIN\AML_Group)
		CREATE LOGIN [NEW-DOMAIN\AML_Group] FROM WINDOWS;

		USE YourDatabase;
		ALTER USER [APP_AML_CDD_APP] WITH LOGIN = [NEW-DOMAIN\AML_Group];

Case C — Group does not exist anymore
	you must either:

	Create the missing AD group
	or
	Drop the user inside the DB (if unused)

USE YourDatabase;
DROP USER [APP_AML_CDD_APP];

################################################################################################

## Checking the status of Always on in RDS :
-----------------------------------------
SELECT CASE WHEN dm.mirroring_state_desc IS NOT NULL THEN 'Multi-AZ (Mirroring)'
    WHEN dhdrs.group_database_id IS NOT NULL THEN 'Multi-AZ (AlwaysOn)'
    ELSE 'Single-AZ'
    END 'high_availability'
FROM sys.databases sd
LEFT JOIN sys.database_mirroring dm ON sd.database_id = dm.database_id
LEFT JOIN sys.dm_hadr_database_replica_states dhdrs ON sd.database_id = dhdrs.database_id AND dhdrs.is_local = 1
WHERE DB_NAME(sd.database_id) = 'rdsadmin';
