Quaries for daily use. 
https://dbaclass.com/monitor-your-db/
https://dbaclass.com/monitor-your-db/
https://dbaclass.com/monitor-your-db/
########  DB CHECK  / DB Size / database size
---------------------------------------------
set lines 200 pages 200
col INST for 999
col STARTUP_TIME for a15
col SYSDATE for a15
col DATABASE_ROLE for a10
col open_mode for a15
col host_name for a15
col status for a8
col DB_UNIQUE_NAME for a10
select name db_name,DB_UNIQUE_NAME,OPEN_MODE,DATABASE_ROLE,INST_ID INST,INSTANCE_NAME,HOST_NAME,to_char(STARTUP_TIME,'DD-MON-YY HH24:MI') STARTUP_TIME, to_char(SYSDATE,'DD-MON-YY HH24:MI') "SYSDATE" , STATUS, LOGINS, CDB from v$database , gv$instance order by inst_id;


ps -ef | grep -i pmon

set lines 200 pages 200
col INST for 999
col STARTUP_TIME for a15
col SYSDATE for a15
col DATABASE_ROLE for a10
col open_mode for a15
col host_name for a15
col status for a9
col DB_UNIQUE_NAME for a10
select name db_name,DB_UNIQUE_NAME,OPEN_MODE,DATABASE_ROLE,INST_ID INST,INSTANCE_NAME,HOST_NAME,to_char(STARTUP_TIME,'DD-MON-YY HH24:MI') STARTUP_TIME, to_char(SYSDATE,'DD-MON-YY HH24:MI') "SYSDATE" , STATUS, LOGINS from v$database , gv$instance order by inst_id;


select
( select sum(bytes)/1024/1024/1024 data_size from cdb_data_files ) +
( select nvl(sum(bytes),0)/1024/1024/1024 temp_size from cdb_temp_files ) +
( select sum(bytes)/1024/1024/1024 redo_size from sys.v_$log ) +
( select sum(BLOCK_SIZE*FILE_SIZE_BLKS)/1024/1024/1024 controlfile_size from v$controlfile) "Size in GB" from dual;

select
( select sum(bytes)/1024/1024/1024 data_size from dba_data_files ) +
( select nvl(sum(bytes),0)/1024/1024/1024 temp_size from dba_temp_files ) +
( select sum(bytes)/1024/1024/1024 redo_size from sys.v_$log ) +
( select sum(BLOCK_SIZE*FILE_SIZE_BLKS)/1024/1024/1024 controlfile_size from v$controlfile) "Size in GB" from dual;




set lines 200 pages 200
col STATUS for a15
col TYPE for a15
col MEMBER for a60
select INST_ID,GROUP#,THREAD#,BYTES,MEMBERS,CON_ID,ARCHIVED,STATUS from gv$log;

select INST_ID,GROUP#,THREAD#,BYTES,CON_ID,ARCHIVED,STATUS from gv$standby_log;

select INST_ID,GROUP#,STATUS,TYPE,MEMBER,CON_ID from gv$logfile;
select to_char(timestamp_to_scn(to_timestamp('19-02-2025 21:15:00','dd-mm-yyyy hh24:mi:ss'))) scn from dual;
SELECT to_char(CURRENT_SCN) FROM gV$DATABASE;
select to_char(min(checkpoint_change#)) from v$datafile_header;


SELECT INST_ID INST,USERNAME,MACHINE,STATUS,COUNT(*) FROM GV$SESSION WHERE USERNAME IS NOT NULL AND USERNAME NOT IN ('SYS','SYSTEM') GROUP BY INST_ID, USERNAME, MACHINE,STATUS ORDER BY 1,5;
SELECT INST_ID INST,USERNAME,MACHINE,STATUS,COUNT(*) FROM GV$SESSION  GROUP BY INST_ID, USERNAME, MACHINE,STATUS ORDER BY 1,5;

SELECT INST_ID INST,USERNAME,MACHINE,STATUS,COUNT(*) FROM GV$SESSION WHERE SQL_ID ='' GROUP BY INST_ID, USERNAME, MACHINE,STATUS ORDER BY 1,5;

select name,open_mode,con_id from v$pdbs;
set lines 200 pages 200
col con_name for a20
col name for a30
col PDB for a20
select con_id, name,PDB from v$services order by con_id, name;
select con_id, name,PDB,ENABLED from cdb_services order by con_id, name;
select con_id,CON_NAME, name,BLOCKED from v$active_services order by con_id, name; 

netstat -tnlp | grep : 8080
netstat -tnlp | grep : 8081

23  
24 putting leave on 24 as taken leave on 26th which is working for me .
27,28,29 put leave worked on the sunday 3rd 
select * from v$recovery_file;
alter system switch logfile;
alter system checkpoint;

alter SESSION set NLS_DATE_FORMAT = 'DD-MM-YYYY HH24:MI:SS';
alter SESSION set NLS_DATE_FORMAT = 'DD-MMM-YYYY HH24:MI:SS';

tar -cvzf $BACKUP_LOC/11.2.0.4_BKP_PSU_JAN2018 11.2.0.4
tar -cvzf $BACKUP_LOC/INVENTROY_BKP_PSU_JAN2018 oraInventory
nohup tar zxvf /oracle/backup/EBSapps_fs1.tar.gz -C /apps/train_122/fs1/ --strip-components 3 &
sqlplus sys/password@primdb_scan as sysdba @run_check.sql

sqlplus user/password@(DESCRIPTION=((ADDRESS=(PROTOCOL = TCP)(HOST = dbhost)(PORT = 1521))(CONNECT_DATA=(SERVICE_NAME = zzz)))
sqlplus sys/W_27iHKmxXfJf@(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=baxdevdb.ebsdbdev.ebscmvcn.oraclevcn.com)(PORT=1521)))

(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=qbe3ebsdb01-scan.qbedev3db.vcnqbenprd.oraclevcn.com) (PORT=5010)))(CONNECT_DATA=((SERVICE_NAME=TQBEII))


$TFA_HOME/tfa/bin/tfactl diagcollect -srdc dbpatchinstall -from "Mar/14/2022 06:30:00" -to "Mar/14/2022 8:30:00"


Windows :
set ORACLE_SID=DB10
echo %ORACLE_SID%
SET PATH=D:\product\11.1.0\db_1\bin;D:\product\11.1.0\db_1\opatch;%PATH%

To check for the Group member in windows :
NET LOCALGROUP ORA_DBA

Cron tab :
https://crontab.guru
#####################################
CREATE USER QBE_ASALUJA IDENTIFIED BY LDdfafd$#23293 DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP PROFILE QBEPROF;
GRANT "CONNECT" TO QBE_ASALUJA;
GRANT "QBE_RO_REPORTING" TO QBE_ASALUJA;

set lines 200 pages 1000
col username for a17
col account_status for a13
col password for a20
col profile for a15
col default_tablespace for a20
col created for a17
col changed for a17
col expired for a16
col locked for a16
select u.name USERNAME,DU.ACCOUNT_STATUS,DU.PROFILE,DU.DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE,to_char(U.CTIME,'DD-MON-YYYY HH24:MI') CREATED,to_char(U.PTIME,'DD-MON-YYYY HH24:MI') CHANGED,
to_char(U.EXPTIME,'DD-MON-YYYY HH24:MI') EXPIRED,TO_CHAR(U.LTIME,'DD-MON-YYYY HH24:MI') LOCKED,U.LCOUNT FAILED_COUNT, COMMON
FROM DBA_USERS DU,USER$ U WHERE DU.USER_ID=U.USER# AND U.NAME ='&USERNAME' ORDER BY 1;

 
select u.name USERNAME,DU.ACCOUNT_STATUS,DU.PROFILE,DU.DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE,to_char(U.CTIME,'DD-MON-YYYY HH24:MI') CREATED,to_char(U.PTIME,'DD-MON-YYYY HH24:MI') CHANGED,
to_char(U.EXPTIME,'DD-MON-YYYY HH24:MI') EXPIRED,TO_CHAR(U.LTIME,'DD-MON-YYYY HH24:MI') LOCKED,U.LCOUNT FAILED_COUNT
FROM DBA_USERS DU,USER$ U WHERE DU.USER_ID=U.USER# AND U.NAME not LIKE '%&USERNAME%' ORDER BY 1;

 DU.ACCOUNT_STATUS !='OPEN';

SELECT 'ALTER USER '||NAME||' IDENTIFIED BY VALUES '''||PASSWORD||''';' FROM USER$ WHERE NAME='&USERNAME';

Check password edition before this.
select PASSWORD_VERSIONS from dba_users where username='&USERNAME';

--A query to generate a password reset command for all expired accounts in 11gR2 

COL "PASSWORD RESET" FOR A65 
SELECT 'ALTER USER ' || P.NAME || ' IDENTIFIED BY VALUES ' || q'[']' || P.PASSWORD || q'[';]' PASSWORD_RESET
FROM USER$ P, DBA_USERS U WHERE P.NAME = U.USERNAME AND P.NAME LIKE  '%&USERNAME%';

--A query to generate a password reset command for all expired accounts in 12c and higher.

SET LINES 200 
SET PAGES 999
COL PASSWORD_RESET FOR A200 WORD_WRAPPED
SELECT 'ALTER USER ' || P.NAME || ' IDENTIFIED BY VALUES ' || q'[']' || P.SPARE4 || q'[';]' PASSWORD_RESET
FROM USER$ P,DBA_USERS U WHERE P.NAME = U.USERNAME AND P.NAME LIKE '%&USERNAME%';

SELECT 'ALTER USER ' || P.NAME || ' IDENTIFIED BY VALUES ' || q'[']' || P.SPARE4 || q'[';]' PASSWORD_RESET
FROM USER$ P,DBA_USERS U WHERE P.NAME = U.USERNAME AND U.ACCOUNT_STATUS LIKE '%EXPIRED%';

SET LINES 200 
SET PAGES 999
COL PASSWORD_RESET FOR A200 WORD_WRAPPED
SELECT 'ALTER USER ' || P.NAME || ' IDENTIFIED BY VALUES ' || q'[']' || P.SPARE4 || q'[';]' PASSWORD_RESET
FROM USER$ P,DBA_USERS U WHERE P.NAME = U.USERNAME AND P.NAME in ('GAEE_AUDITLOG','GAEE_RO','GAEE_COMMON','GAEE_STAGING');

select name, password from sys.user$ where name='XXAWEB2';
select name, spare4 from sys.user$ where name='XXAWEB2';

select ROLE,COMMON,ORACLE_MAINTAINED from dba_roles where role='&ROLE';


Set lines 200 pages 200
COL GRANTEE FOR A25
COL GRANTED_ROLE FOR A25
COL DEFAULT_ROLE FOR A15
SELECT GRANTEE,GRANTED_ROLE,DEFAULT_ROLE FROM DBA_ROLE_PRIVS WHERE GRANTEE='&GRANTEE' ORDER BY GRANTED_ROLE;

Set lines 200 pages 200
COL GRANTEE FOR A25
COL OWNER FOR 25
COL TABLE_NAME FOR A30
COL PRIVILEGE FOR A15
SELECT GRANTEE,PRIVILEGE FROM DBA_SYS_PRIVS WHERE GRANTEE='&GRANTEE';

Set lines 200 pages 200
COL GRANTEE FOR A25
COL OWNER FOR 25
COL TABLE_NAME FOR A30
COL PRIVILEGE FOR A15
SELECT GRANTEE,OWNER,TABLE_NAME,PRIVILEGE FROM DBA_TAB_PRIVS WHERE GRANTEE='&GRANTEE' ORDER BY TABLE_NAME;


SELECT GRANTEE,GRANTED_ROLE,DEFAULT_ROLE FROM DBA_ROLE_PRIVS WHERE GRANTEE='&GRANTEE' 
union 
SELECT GRANTEE,PRIVILEGE FROM DBA_SYS_PRIVS WHERE GRANTEE='&GRANTEE'
union 
SELECT GRANTEE,OWNER,TABLE_NAME,PRIVILEGE FROM DBA_TAB_PRIVS WHERE GRANTEE='&GRANTEE';


SELECT * FROM DBA_TS_QUOTAS WHERE TABLESPACE_NAME LIKE '%&TABLESPACE_NAME%' AND USERNAME LIKE '%&USERNAME%' ORDER BY USERNAME,TABLESPACE_NAME;

SELECT PROPERTY_NAME, PROPERTY_VALUE FROM DATABASE_PROPERTIES WHERE PROPERTY_NAME IN ('DEFAULT_PERMANENT_TABLESPACE','DEFAULT_TEMP_TABLESPACE');
ALTER DATABASE DEFAULT TABLESPACE USERS;
XXQBE_APRO_RO_PROD
XXQBE_FDW_RO
XXQBE_DPL_RO
create user MANASAVANAJAKSHIJ profile DEFAULT identified by XXXXXX PASSWORD EXPIRE;
GRANT XXQBE_FDW_RO TO MANASAVANAJAKSHIJ;
GRANT CONNECT TO MANASAVANAJAKSHIJ;
GRANT CREATE SESSION TO MANASAVANAJAKSHIJ;

create user HARSHINIR profile QBEPROF identified by XXXXXX PASSWORD EXPIRE;
GRANT CONNECT TO HARSHINIR;
GRANT XXQBE_APRO_RO_PROD TO HARSHINIR;
GRANT CREATE SESSION TO HARSHINIR;

MANASAVANAJAKSHI.Jaliparthi@qbe.com

MANASAVANAJAKSHIJ
 
GRANT PRIVILEGE TO X1 LIKE B1:
-------------------------------
SELECT 'GRANT '||GRANTED_ROLE||' TO &TO;' FROM DBA_ROLE_PRIVS WHERE GRANTEE='&LIKE'
union all
SELECT 'GRANT '||PRIVILEGE||' TO &TO;' FROM DBA_SYS_PRIVS WHERE GRANTEE='&LIKE'
union all
SELECT 'GRANT '||PRIVILEGE||' ON '||OWNER||'.'||TABLE_NAME||' TO &TO ;' FROM DBA_TAB_PRIVS WHERE GRANTEE='&LIKE';


GRANT PRIVS ON TABLE
---------------------
SELECT 'GRANT SELECT,INSERT,UPDATE,DELETE ON '||OWNER||'.'||TABLE_NAME||' TO &GRANTEE;' FROM DBA_TABLES WHERE OWNER='&OWNER';
SELECT 'GRANT EXECUTE ON '||OWNER||'.'||OBJECT_NAME||' TO &GRANTEE;' FROM DBA_OBJECTS WHERE OWNER='&OWNER' AND OBJECT_TYPE IN ('PACKAGE','PROCEDURE','FUNCTION');
SELECT 'GRANT SELECT ON '||OWNER||'.'||OBJECT_NAME||' TO &GRANTEE;' FROM DBA_OBJECTS WHERE OWNER='&OWNER' AND OBJECT_TYPE IN ('VIEW','SEQUENCE');
SELECT 'GRANT DEBUG ON '||OWNER||'.'||OBJECT_NAME||' TO &GRANTEE;' FROM DBA_OBJECTS WHERE OWNER='&OWNER' AND OBJECT_TYPE IN ('PACKAGE','PROCEDURE');

READ :
SELECT 'GRANT SELECT ON '||OWNER||'.'||OBJECT_NAME||' TO &GRANTEE;' FROM DBA_OBJECTS WHERE OWNER='&OWNER' AND OBJECT_TYPE IN ('TABLE','VIEW');

READ AND WRITE :
SELECT 'GRANT SELECT,INSERT,UPDATE,DELETE ON '||OWNER||'.'||OBJECT_NAME||' TO &APP_ROLE;' FROM DBA_OBJECTS WHERE OWNER='&SCHEMA_NAME' AND OBJECT_TYPE='TABLE';
UNION
SELECT 

set long 20000
select dbms_metadata.get_ddl('USER', u.username) AS ddl from dba_users u where  u.username = '&USERNAME';


SELECT username, userhost, terminal, timestamp, returncode 
FROM dba_audit_session 
WHERE returncode = 1017 -- ORA-01017: Invalid username/password
ORDER BY timestamp DESC;

SELECT event_timestamp, os_username, DBUSERNAME, return_code, authentication_type, client_program_name 
FROM unified_audit_trail 
WHERE return_code = 1017
ORDER BY event_timestamp DESC;


Get DDL of the objects :
----------------------------
set long 999999999
set lines 500 pages 200
set head off
select DBMS_METADATA.GET_DDL('&OBJECT_TYPE','&OBJECT_NAME','&OWNER') FROM DUAL;
SELECT DBMS_METADATA.GET_DDL('&OBJECT_TYPE', '&OBJECT_NAME') FROM DUAL;

INDEX / TABLE / PACKAGE / VIEW / PACKAGE_BODY / CONSTRAINTS / TRIGGER / SEQUENCE 
ROLE / TABLESPACE / REF_CONSTRAINT / SYNONYM / ROLE_GRANT / OBJECT_GRANT / SYSTEM_GRANT


Common quaries :
column current_scn format 99999999999999999999;
select current_scn from v$database;

####################### Database user Profile:
set lines 200 pages 200
col PROFILE for a40
col LIMIT for a50
select distinct PROFILE from dba_profiles ;
select * from dba_profiles where PROFILE='&PROFILE';
select * from dba_profiles where resource_name = '&RESOURCE_NAME';
ALTER PROFILE DEFAULT LIMIT PASSWORD_REUSE_TIME UNLIMITED;
ALTER PROFILE DEFAULT LIMIT PASSWORD_REUSE_MAX UNLIMITED;
ALTER PROFILE DEFAULT LIMIT PASSWORD_REUSE_TIME 365;
ALTER PROFILE DEFAULT LIMIT PASSWORD_REUSE_MAX 5;
ALTER PROFILE DEFAULT LIMIT PASSWORD_VERIFY_FUNCTION NULL;
ALTER PROFILE DEFAULT LIMIT PASSWORD_VERIFY_FUNCTION ORA12C_STRONG_VERIFY_FUNCTION; 
ALTER USER ORDS_PUBLIC_USER PROFILE DEFAULT ;
ALTER PROFILE DEFAULT LIMIT PASSWORD_VERIFY_FUNCTION NULL;

ALTER USER XXQBE_DPL_COMMON PROFILE DEFAULT ;
alter user INOAPPS_COMMON identified by M2Liac#i1#123 account unlock;
##################  Tablespace Usage
set pages 999
set lines 400
SELECT df.tablespace_name tablespace_name,
 max(df.autoextensible) auto_ext,
 round(df.maxbytes / (1024 * 1024), 2) max_ts_size,
 round((df.bytes - sum(fs.bytes)) / (df.maxbytes) * 100, 2) max_ts_pct_used,
 round(df.bytes / (1024 * 1024), 2) curr_ts_size,
 round((df.bytes - sum(fs.bytes)) / (1024 * 1024), 2) used_ts_size,
 round((df.bytes-sum(fs.bytes)) * 100 / df.bytes, 2) ts_pct_used,
 round(sum(fs.bytes) / (1024 * 1024), 2) free_ts_size,
 nvl(round(sum(fs.bytes) * 100 / df.bytes), 2) ts_pct_free
FROM dba_free_space fs,
 (select tablespace_name,
 sum(bytes) bytes,
 sum(decode(maxbytes, 0, bytes, maxbytes)) maxbytes,
 max(autoextensible) autoextensible
 from dba_data_files
 group by tablespace_name) df
WHERE fs.tablespace_name (+) = df.tablespace_name
GROUP BY df.tablespace_name, df.bytes, df.maxbytes
UNION ALL
SELECT df.tablespace_name tablespace_name,
 max(df.autoextensible) auto_ext,
 round(df.maxbytes / (1024 * 1024), 2) max_ts_size,
 round((df.bytes - sum(fs.bytes)) / (df.maxbytes) * 100, 2) max_ts_pct_used,
 round(df.bytes / (1024 * 1024), 2) curr_ts_size,
 round((df.bytes - sum(fs.bytes)) / (1024 * 1024), 2) used_ts_size,
 round((df.bytes-sum(fs.bytes)) * 100 / df.bytes, 2) ts_pct_used,
 round(sum(fs.bytes) / (1024 * 1024), 2) free_ts_size,
 nvl(round(sum(fs.bytes) * 100 / df.bytes), 2) ts_pct_free
FROM (select tablespace_name, bytes_used bytes
 from V$temp_space_header
 group by tablespace_name, bytes_free, bytes_used) fs,
 (select tablespace_name,
 sum(bytes) bytes,
 sum(decode(maxbytes, 0, bytes, maxbytes)) maxbytes,
 max(autoextensible) autoextensible
 from dba_temp_files
 group by tablespace_name) df
WHERE fs.tablespace_name (+) = df.tablespace_name
GROUP BY df.tablespace_name, df.bytes, df.maxbytes
ORDER BY 4 DESC;

set pages 999
set lines 400
col TABLESPACE_NAME  format a20
col FILE_NAME format a55
select d.TABLESPACE_NAME, d.FILE_NAME, d.BYTES/1024/1024/1024 SIZE_GB, d.AUTOEXTENSIBLE, d.MAXBYTES/1024/1024/1024 MAXSIZE_GB,
d.INCREMENT_BY*(v.BLOCK_SIZE/1024)/1024 INCREMENT_BY_MB from dba_data_files d,  v$datafile v where d.FILE_ID = v.FILE# and
tablespace_name='&TABLESPACE_NAME' order by d.TABLESPACE_NAME, d.FILE_NAME;

show parameter db_create_file_dest
ALTER TABLESPACE &TABLESPACE_NAME ADD DATAFILE SIZE 1G AUTOEXTEND ON NEXT 1G MAXSIZE 31G;
ALTER DATABASE DATAFILE '&DATAFILE_PATH_NAME' autoextend on next 1G maxsize 31g;
ALTER TABLESPACE STEPSYSDATA ADD DATAFILE '/u02/oradata/stepdev/stepsysdata_stepdev_1.dbf' SIZE 1G AUTOEXTEND ON NEXT 1G MAXSIZE 31G;
ALTER TABLESPACE APPS_TS_TX_DATA ADD DATAFILE '+DATA' SIZE 1G AUTOEXTEND ON NEXT 1G MAXSIZE 31G;
alter database datafile '+DATA/devdb01/datafile/perfstat.275.879776925' resize 1G;
ALTER DATABASE DATAFILE '+DATA/devdb01/datafile/perfstat.275.879776925' autoextend on next 100M maxsize 5g;

ALTER TABLESPACE STEPSYSDATA ADD DATAFILE '/u02/oradata/stepprod/stepsysdata_stepprod_20.dbf' SIZE 1G AUTOEXTEND ON NEXT 1G MAXSIZE 31G;

CREATE TABLESPACE perfstat DATAFILE '+DATA' SIZE 1G AUTOEXTEND ON NEXT 100M MAXSIZE 5G;
CREATE BIGFILE TABLESPACE big_ts DATAFILE '/u01/oradata/ORCL/big_ts01.dbf' SIZE 10G AUTOEXTEND ON NEXT 1G MAXSIZE 100G;
CREATE TABLESPACE encrypt_ts DATAFILE '$ORACLE_HOME/dbs/encrypt_df.dbf' SIZE 10G AUTOEXTEND ON NEXT 1G MAXSIZE 100G ENCRYPT;

select FILE_NAME,FILE_ID,TABLESPACE_NAME,ddf.STATUS,AUTOEXTENSIBLE,MAXBYTES/1024/1024/1024,INCREMENT_BY,df.CREATION_TIME
from dba_data_files ddf, v$datafile df where df.FILE#=ddf.FILE_ID and ddf.FILE_NAME='+DATA/olap/datafile/bobjdata_pmix_indices.983.1108018415';

ASM Disk group size 
=====================
SET LINESIZE  145
SET PAGESIZE  9999
SET VERIFY    off
COLUMN group_name FORMAT a20 HEAD 'Disk Group|Name'
COLUMN sector_size FORMAT 99,999   HEAD 'Sector|Size'
COLUMN block_size  FORMAT 99,999   HEAD 'Block|Size'
COLUMN allocation_unit_size   FORMAT 999,999,999   HEAD 'Allocation|Unit Size'
COLUMN state   FORMAT a11   HEAD 'State'
COLUMN type   FORMAT a6 HEAD 'Type'
COLUMN total_mb    FORMAT 999,999,999   HEAD 'Total Size (MB)'
COLUMN used_mb   FORMAT 999,999,999   HEAD 'Used Size (MB)'
COLUMN pct_used   FORMAT 999.99  HEAD 'Pct. Used'

break on report on disk_group_name skip 1
compute sum label "Grand Total: " of total_mb used_mb on report

SELECT
    name                                     group_name
  , sector_size                              sector_size
  , block_size                               block_size
  , allocation_unit_size                     allocation_unit_size
  , state                                    state
  , type                                     type
  , total_mb                                 total_mb
  , (total_mb - free_mb)                     used_mb
  , ROUND((1- (free_mb / total_mb))*100, 2)  pct_used
FROM
    v$asm_diskgroup
ORDER BY
    name
/

	

Historical ASM usage details from OEM view  : 

select key_value,target_name,column_label,Average, Minimum, Maximum, rollup_timestamp
from sysman.MGMT$METRIC_DAILY
where metric_name='DiskGroup_Usage'
and column_label = 'Disk Group Free (MB)'
and TARGET_NAME='+ASM_Cluster-c2'
and KEY_VALUE='DATAC2'
and TO_CHAR(rollup_timestamp,'DD-MON-YYYY HH24:MI') between '22-11-2024 09:00' and '23-11-2024 10:00'
order by rollup_timestamp desc;


2024-11-22T09:09:48.117369+00:00

Tablespace growth rate :
========================
https://www.oraclenext.com/2017/11/segment-space-growth-history-and.html
https://blog.pythian.com/how-to-retrieve-growth-history-for-oracle-tablespaces/

break on resized
    with ts_history as (
  select * from (
  select v.name
,        v.ts#
,        s.instance_number
,        h.tablespace_size
       * p.value/1024/1024              ts_mb
,        h.tablespace_maxsize
       * p.value/1024/1024              max_mb
,        h.tablespace_usedsize
       * p.value/1024/1024              used_mb
,        to_date(h.rtime, 'MM/DD/YYYY HH24:MI:SS') resize_time
,        lag(h.tablespace_usedsize * p.value/1024/1024, 1, h.tablespace_usedsize * p.value/1024/1024)
         over (partition by v.ts# order by h.snap_id) last
,        (h.tablespace_usedsize * p.value/1024/1024)
       - lag(h.tablespace_usedsize * p.value/1024/1024, 1, h.tablespace_usedsize * p.value/1024/1024)
         over (partition by v.ts# order by h.snap_id) incr
    from dba_hist_tbspc_space_usage     h
,        dba_hist_snapshot              s
,        v$tablespace                   v
,        dba_tablespaces                t
,        v$parameter                    p
   where h.tablespace_id                = v.ts#
     and v.name                         = t.tablespace_name
     and t.contents                not in ('UNDO', 'TEMPORARY')
     and p.name                         = 'db_block_size'
     and h.snap_id                      = s.snap_id
order by v.name, h.snap_id asc)
   where incr > 0)
  select to_char(resize_time, 'YYYY-MM') as resized
,        name
,        sum(incr)                      incr
    from ts_history
group by name
,        to_char(resize_time, 'YYYY-MM')
order by 1, 3 desc;

Segement growth rate :
======================
=> Get the object ID (and current size, if needed) for the segment about which segment space usage information is needed.
select owner,object_id from dba_objects where object_name='&OBJECT_NAME';

select instance_number,max(startup_time) STARTUPT_TIME, TRUNC(sysdate-trunc(max(startup_time))) NUM_DAYS from 
dba_hist_snapshot group by instance_number order by 2;

=> Query in the above step gives information about the instance startup time. However, we need first AWR Snapshot ID after this instance restart time. 
   Data growth information will be based on AWR data captured starting that snapshot until the latest snapshot.

select instance_number,min(snap_id) snap_id from dba_hist_snapshot where (instance_number,startup_time) in (select instance_number,max(startup_time) 
from dba_hist_snapshot group by instance_number) group by instance_number order by snap_id;


select ROUND(SUM(space_allocated/1024/1024)) growth_mb, ROUND(SUM(space_allocated/1024/1024)/7) per_day_growth_mb,
ROUND(SUM(space_allocated/1024/1024)/7*30) expected_growth_mb_next30days
from (select max(space_allocated_total) space_allocated from dba_hist_seg_stat where obj#=&OBJECT_ID and snap_id >= snap_id group by instance_number);

TOP segement :
--------------
set lines 200 pages 200
col owner for a15
col segment_name for a35
col tablespace_name for a20
select owner,segment_name,segment_type,tablespace_name,round(sum(bytes)/1024/1024/1024,2) SIZE_IN_GB 
from DBA_SEGMENTS
where BYTES/1024/1024/1024 < 5 
group by owner,segment_name,segment_type,tablespace_name
order by owner,round(sum(bytes)/1024/1024/1024,2);

set lines 200 pages 200
col owner for a15
col segment_name for a35
col tablespace_name for a20
select owner,segment_name,segment_type,tablespace_name,round(sum(bytes)/1024/1024/1024,2) SIZE_IN_GB 
from DBA_SEGMENTS
where BYTES/1024/1024/1024 > 2 and tablespace_name='&TABLESPACE_NAME'
group by owner,segment_name,segment_type,tablespace_name
order by owner,round(sum(bytes)/1024/1024/1024,2);

select owner,segment_type,tablespace_name,round(sum(bytes)/1024/1024/1024,2) SIZE_IN_GB 
from DBA_SEGMENTS where owner in () group by owner,segment_type,tablespace_name
order by owner;

=> Following is the query that will show how much the segment TEST has grown since last 7 days (Since startup of the instance 1), 
   how much was per day growth in last 7 days, and how much it may grow during next 30 days.
   Highlighted in yellow is the value to calculate the size growth per day for last n number of days, and highlighted in red is to calculate 
   the expected growth in next n number of days. If our last instance startup was 20 days ago, the value highlighted in yellow will be 20. 
   To forecast the growth for next 45 days, the values highlighted in red will be 20*45

select owner,segment_name,segment_type,tablespace_name,round(sum(bytes)/1024/1024/1024,2) SIZE_IN_GB 
from DBA_SEGMENTS having round(sum(bytes)/1024/1024/1024,2) > 5 group by owner,segment_name,segment_type,tablespace_name;

select ROUND(SUM(space_allocated/1024/1024)) growth_mb, ROUND(SUM(space_allocated/1024/1024)/7) per_day_growth_mb,
ROUND(SUM(space_allocated/1024/1024)/7*30) expected_growth_mb_next30days
from (select max(space_allocated_total) space_allocated from dba_hist_seg_stat where obj#=427055 and snap_id>=220328 group by instance_number);

select ROUND(SUM(space_allocated/1024/1024)) growth_mb, ROUND(SUM(space_allocated/1024/1024)/&NUM_DAYS) per_day_growth_mb,
ROUND(SUM(space_allocated/1024/1024)/7*&Expected_growth_days) expected_growth_mb_next30days
from (select max(space_allocated_total) space_allocated from dba_hist_seg_stat where obj#=&object_id and snap_id>=&Min_snap_id group by instance_number);


UNDO Tablespace :
=================
with free_sz as ( select tablespace_name, sum(f.bytes)/1048576/1024 free_gb from dba_free_space f group by tablespace_name ) , 
a as ( select tablespace_name , sum(case when status = 'EXPIRED' then blocks end)*8/1048576 reusable_space_gb , 
sum(case when status in ('ACTIVE', 'UNEXPIRED') then blocks end)*8/1048576 allocated_gb from dba_undo_extents 
where status in ('ACTIVE', 'EXPIRED', 'UNEXPIRED') group by tablespace_name ) , undo_sz as ( select tablespace_name, 
df.user_bytes/1048576/1024 user_sz_gb from dba_tablespaces ts join dba_data_files df using (tablespace_name) 
where ts.contents = 'UNDO' and ts.status = 'ONLINE' ) select tablespace_name, user_sz_gb, free_gb, reusable_space_gb, 
allocated_gb , free_gb + reusable_space_gb + allocated_gb total from undo_sz join free_sz using (tablespace_name) 
join a using (tablespace_name) ;

1. To check the current size of the Undo tablespace:
select sum(a.bytes)/1024/1024/1024 as undo_size_GB from v$datafile a, v$tablespace b, dba_tablespaces c where c.contents = 'UNDO' and c.status = 'ONLINE' 
and b.name = c.tablespace_name and a.ts# = b.ts#;

2. To check the free space (unallocated) space within Undo tablespace:
select sum(bytes)/1024/1024 "mb" from dba_free_space where tablespace_name ='&undo_tablespace_name';

3.To Check the space available within the allocated Undo tablespace:
select tablespace_name , sum(blocks)*8/(1024)  reusable_space from dba_undo_extents where status='EXPIRED'  group by  tablespace_name;

4. To Check the space allocated in the Undo tablespace:
select tablespace_name , sum(blocks)*8/(1024)  space_in_use from dba_undo_extents where status IN ('ACTIVE','UNEXPIRED') 
group by  tablespace_name;


undo tablespace usage :
-----------------------
column tablespace format a20;
column sum_in_mb format 999999.99;
select tablespace_name tablespace, status, sum(bytes)/1024/1024 sum_in_mb, count(*) counts from dba_undo_extents 
group by tablespace_name, status order by 1,2;

UNDO tablespace usage by schema :
---------------------------------
select u.tablespace_name tablespace, s.username, u.status, sum(u.bytes)/1024/1024 sum_in_mb, count(u.segment_name) seg_cnts 
from dba_undo_extents u left join v$transaction t on u.segment_name = '_SYSSMU' || t.xidusn || '$' left join v$session s on 
t.addr = s.taddr group by u.tablespace_name, s.username, u.status order by 1,2,3;

UNDO by session wise :
-----------------------
select s.sid,s.status,
s.username,
sum(ss.value) / 1024 / 1024 as undo_size_mb
from v$sesstat ss
join v$session s on s.sid = ss.sid
join v$statname stat on stat.statistic# = ss.statistic#
where stat.name = 'undo change vector size' and s.type= 'BACKGROUND'
and s.username IS NOT NULL
group by s.sid,s.username,s.status;

Historical Undo tablespace usage :
==================================
with t as (
select ss.run_time,ts.name,round(su.tablespace_size*dt.block_size/1024/1024/1024,2) alloc_size_gb,
round(su.tablespace_usedsize*dt.block_size/1024/1024/1024,2) used_size_gb
from
dba_hist_tbspc_space_usage su,
(select trunc(BEGIN_INTERVAL_TIME) run_time,max(snap_id) snap_id from dba_hist_snapshot
group by trunc(BEGIN_INTERVAL_TIME) ) ss,
v$tablespace ts,
dba_tablespaces dt
where su.snap_id = ss.snap_id
and su.tablespace_id = ts.ts#
and ts.name in ('UNDOTBS1')
and ts.name = dt.tablespace_name )
select e.run_time,e.name,e.alloc_size_gb,e.used_size_gb curr_used_size_gb,b.used_size_gb prev_used_size_gb,
 (e.used_size_gb - b.used_size_gb) as variance
from t e, t b
where e.run_time = b.run_time + 1
order by 1;

Optimum UNDO retention :
========================
SELECT d.undo_size/(1024*1024) as UNDO_SIZE,
       SUBSTR(e.value,1,25) as UNDO_RETENTION,
       ROUND((d.undo_size / (to_number(f.value) *
       g.undo_block_per_sec))) as OPTIMUM_UNDO_RETENTION
  FROM (
       SELECT SUM(a.bytes) undo_size
          FROM v$datafile a,
               v$tablespace b,
               dba_tablespaces c
         WHERE c.contents = 'UNDO'
           AND c.status = 'ONLINE'
           AND b.name = c.tablespace_name
           AND a.ts# = b.ts#
       ) d,
       v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
              undo_block_per_sec
         FROM v$undostat
       ) g
WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size';

Optimal UNDO size :
===================
SELECT d.undo_size/(1024*1024) as UNDO_SIZE,
       SUBSTR(e.value,1,25) as UNDO_RETENTION,
       (TO_NUMBER(e.value) * TO_NUMBER(f.value) *
       g.undo_block_per_sec) / (1024*1024)
      as "NEEDED_UNDO_SIZE"
  FROM (
       SELECT SUM(a.bytes) undo_size
         FROM v$datafile a,
              v$tablespace b,
              dba_tablespaces c
        WHERE c.contents = 'UNDO'
          AND c.status = 'ONLINE'
          AND b.name = c.tablespace_name
          AND a.ts# = b.ts#
       ) d,
      v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
         undo_block_per_sec
         FROM v$undostat
       ) g
 WHERE e.name = 'undo_retention' AND f.name = 'db_block_size';
 
TEMP Tablespace :
=================
v$tempseg_usage reports temp space usage per session
v$tempseg_usage (9i onwards) is v$sort_usage, which is retained for backward compatibility and removed from Oracle Docu.

Size of temp tablespace :
-------------------------
col file_name for a60
col TABLESPACE_NAME for a17
col MAXBYTES clear
select FILE_NAME,TABLESPACE_NAME,BYTES/1024/1024/1024 BYTES_GB,STATUS,AUTOEXTENSIBLE,MAXBYTES/1024/1024/1024 MAXBYTES_IN_GB from dba_temp_files where tablespace_name='%&TEMP_TABLESPACE%';

select TABLESPACE_NAME,sum(bytes)/1024/1024/1024 gb from dba_temp_files group by TABLESPACE_NAME ;
alter database tempfile '+DATA/CBAXPRD1_LHR1KK/2F7A5B7884917631E05325F5558C16D7/TEMPFILE/temp2.520.1077500231' resize 10G;
alter database tempfile '&TEMPFILE' autoextend on next 1G maxsize 20g;
SELECT 'alter database tempfile '''|| file_name || ''' drop ;' from dba_temp_files order by TABLESPACE_NAME,FILE_ID;

SELECT 'ALTER TABLESPACE ' || TABLESPACE_NAME || ' ADD TEMPFILE ''' || FILE_NAME || ''' SIZE ' || BYTES / 1024 / 1024 || 'M REUSE;' FROM DBA_TEMP_FILES order by TABLESPACE_NAME,FILE_ID ;

alter tablespace temp add tempfile '&TEMPFILE' size 1G autoextend on next 1G maxsize 31g;

alter tablespace temp add tempfile '/u02/oradata/IFSTESTCifslive/tempc01.dbf' size 1G autoextend on next 1G maxsize 31g;

alter tablespace temp add tempfile '/u02/oradata/IFSTESTCa59dac69ddb1e26ce0530bd1650afb0f/tempfile/temp01.dbf' size 1G autoextend on next 1G maxsize 31g;
alter tablespace temp add tempfile '/u02/oradata/IFSTESTCa59dac69ddb1e26ce0530bd1650afb0f/tempfile/temp02.dbf' size 1G autoextend on next 1G maxsize 31g;
alter tablespace temp add tempfile '/u02/oradata/IFSTESTCa59dac69ddb1e26ce0530bd1650afb0f/tempfile/temp03.dbf' size 1G autoextend on next 1G maxsize 31g;
alter tablespace temp add tempfile '/u02/oradata/IFSTESTCa59dac69ddb1e26ce0530bd1650afb0f/tempfile/temp04.dbf' size 1G autoextend on next 1G maxsize 31g;
alter tablespace temp add tempfile '/u02/oradata/IFSTESTCa59dac69ddb1e26ce0530bd1650afb0f/tempfile/temp05.dbf' size 1G autoextend on next 1G maxsize 31g;
alter tablespace temp add tempfile '/u02/oradata/IFSTESTCa59dac69ddb1e26ce0530bd1650afb0f/tempfile/temp06.dbf' size 1G autoextend on next 1G maxsize 31g;

Current temp tablespace usage :
--------------------------------
select tablespace_name, allocated_space/1024/1024/1024,free_space/1024/1024/1024 from dba_temp_free_space;

select (s.tot_used_blocks/f.total_blocks)*100 as "percent used"
from (select sum(used_blocks) tot_used_blocks from 
v$sort_segment where tablespace_name='tbsp_name') s, 
(select sum(blocks) total_blocks from 
dba_temp_files where tablespace_name='tbsp_name') f;

Query to check Temp Tablespace Usage :
---------------------------------------
SELECT A.tablespace_name tablespace, D.mb_total,
    SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_used,
    D.mb_total - SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_free
   FROM v$sort_segment A,
    (
   SELECT B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total
    FROM v$tablespace B, v$tempfile C
     WHERE B.ts#= C.ts#
      GROUP BY B.name, C.block_size) D
    WHERE A.tablespace_name = D.name
    GROUP by A.tablespace_name, D.mb_total;

Temp Tablespace usage by session :
----------------------------------
SELECT   S.sid || ',' || S.serial# sid_serial, S.username, S.osuser, P.spid, S.module,
          P.program, SUM (T.blocks) * TBS.block_size / 1024 / 1024 mb_used, T.tablespace,
          COUNT(*) statements
 FROM     v$sort_usage T, v$session S, dba_tablespaces TBS, v$process P
 WHERE    T.session_addr = S.saddr
 AND      S.paddr = P.addr
 AND      T.tablespace = TBS.tablespace_name
 GROUP BY S.sid, S.serial#, S.username, S.osuser, P.spid, S.module,
          P.program, TBS.block_size, T.tablespace
 ORDER BY sid_serial;

SELECT a.username, a.SID, a.serial#, a.osuser, b.TABLESPACE, b.blocks,
c.sql_text
FROM v$session a, v$tempseg_usage b, v$sqlarea c
WHERE a.saddr = b.session_addr
AND c.address = a.sql_address
AND c.hash_value = a.sql_hash_value
ORDER BY b.TABLESPACE, b.blocks;

select USER_ID,sql_id
Historical temp usage :

select sql_id,max(TEMP_SPACE_ALLOCATED)/(1024*1024*1024) gig
from gv$active_session_history
where
sample_time > sysdate-2 and
TEMP_SPACE_ALLOCATED > (1024*1024*1024)
group by sql_id order by 2;

select sql_id,max(TEMP_SPACE_ALLOCATED)/(1024*1024*1024) gig from DBA_HIST_ACTIVE_SESS_HISTORY where sample_time > sysdate-2 and TEMP_SPACE_ALLOCATED > (1*1024*1024*1024) group by sql_id order by sql_id;

select sql_id,to_char(sample_time,'dd-mm-yyyy hh24:mi:ss') from gv$active_session_history where sql_id='ccm892fz72028' and TEMP_SPACE_ALLOCATED > (1*1024*1024*1024);
select B.SQL_FULLTEXT from  V$SQL B WHERE B.SQL_ID='&SQL_ID';
select B.SQL_TEXT from dba_hist_sqltext B WHERE B.SQL_ID='&SQL_ID';

select sql_id,max(TEMP_SPACE_ALLOCATED)/(1024*1024*1024) gig from DBA_HIST_ACTIVE_SESS_HISTORY where 
sample_time > sysdate-2 and 
TEMP_SPACE_ALLOCATED > (1*1024*1024*1024) 
group by sql_id order by sql_id;

select sql_id,max(TEMP_SPACE_ALLOCATED)/(1024*1024*1024) gig from DBA_HIST_ACTIVE_SESS_HISTORY 
where sample_time between to_date('2025/05/20 01:00:00','YYYY/MM/DD HH24:MI:SS') and to_date('2025/05/20 18:15:00','YYYY/MM/DD HH24:MI:SS') and
TEMP_SPACE_ALLOCATED > (1*1024*1024*1024) 
group by sql_id order by sql_id;

SELECT 
    TO_CHAR(sample_time, 'YYYY-MM-DD HH24:MI') AS sample_time,
    session_id,
    session_serial#,
    sql_id,
    temp_space_allocated/1024/1024 AS temp_mb
FROM (
    SELECT 
        sample_time,
        session_id,
        session_serial#,
        sql_id,
        temp_space_allocated,
        RANK() OVER (PARTITION BY TO_CHAR(sample_time, 'YYYY-MM-DD HH24:MI') 
                     ORDER BY temp_space_allocated DESC) AS rnk
    FROM 
        dba_hist_active_sess_history
    WHERE 
        temp_space_allocated > 0
)
WHERE rnk <= 5
ORDER BY sample_time DESC, temp_mb DESC;


Shrinking of tablespace :
=========================
set verify off
column file_name format a50 word_wrapped
column smallest format 999,990 heading "Smallest|Size|Poss."
column currsize format 999,990 heading "Current|Size"
column savings  format 999,990 heading "Poss.|Savings"
break on report
compute sum of savings on report
column value new_val blksize
select value from v$parameter where name = 'db_block_size';
/
select file_name,
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) smallest,
       ceil( blocks*&&blksize/1024/1024) currsize,
       ceil( blocks*&&blksize/1024/1024) -
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) savings
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+) order by savings desc
/


## Lobs
select 'ALTER TABLE '||s.owner||'.'||l.table_name||' MOVE LOB('||l.column_name||') STORE AS (TABLESPACE USERNAME) online;' 
  from dba_segments s, dba_lobs l
 where s.segment_name = l.segment_name
   and s.tablespace_name = '&tablespace_name'
   and segment_type='LOBSEGMENT'
   and partition_name is null;

## Tables move
select 'ALTER TABLE '||owner||'.'||table_name||' move tablespace '||'USERNAME online;' from dba_tables where tablespace_name='USERS'and Owner='USERNAME';


## Move / rebuild indexes 
select 'ALTER INDEX '||owner||'.'||index_name||' REBUILD TABLESPACE '||'USERNAME_INDEX parallel 8 online;' 
from dba_indexes where tablespace_name='USERS';


## Lob Index move 
select 'alter table '||owner||'.'||table_name||' move lob ('||column_name||') store as '||SEGMENT_NAME||' (tablespace USERNAME_INDEX);'from dba_lobs where OWNER='USERNAME' and tablespace_name='USERS';

##
Check Lob indexes
select index_name,index_type,partitioned, table_name,table_type, tablespace_name from dba_indexes where tablespace_name='USERNAME' order by 3;
select index_name,index_type,partitioned,STATUS, table_name,table_type, tablespace_name from dba_indexes where index_name='&index_name' order by 3;
SELECT index_name, partition_name, status, NUM_ROWS FROM dba_ind_partitions WHERE index_name='&index_name' ORDER BY 1,2;
select index_name,index_type, table_name,table_type, tablespace_name from dba_indexes where owner='&OWNER' and index_type='LOB' and tablespace_name='&tablespace_name' order by 3;


Indoubt transaction :
=====================
select 'rollback force '''||local_tran_id||''';' from DBA_2PC_PENDING where state='prepared';

select 'commit force '''||local_tran_id||''';' from DBA_2PC_PENDING where state='prepared';
##################Referencial Integrity

Get the list of Child Tables for a given Table :

SET LINES 300
col parent_owner format A15
col child_owner format A15
col parent_table format A30
col child_table format A30
col parent_cons_name format A30
col child_cons_name format A30

SELECT 
      p.owner parent_owner, 
      c.owner child_owner, 
      p.table_name Parent_table, 
      p.constraint_name parent_cons_name, 
      c.table_name Child_table, 
      c.constraint_name child_cons_name
  FROM 
      dba_constraints p, dba_constraints c
where p.owner='&parent_Owner'
  and p.table_name='&Parent_Table_Name'
  and p.constraint_type IN ('P','U')
  and c.constraint_type='R' 
  and p.owner=c.r_owner
  and p.constraint_name=c.r_constraint_name
order by 4;

Get the List of Parent Table for a given Child Table :

SET LINES 300
col parent_owner format A15
col child_owner format A15
col parent_table format A30
col child_table format A30
col parent_cons_name format A30
col child_cons_name format A30

SELECT 
      p.owner parent_owner, 
      c.owner child_owner, 
      p.table_name Parent_table, 
      p.constraint_name parent_cons_name, 
      c.table_name Child_table, 
      c.constraint_name child_cons_name
  FROM 
      dba_constraints p, dba_constraints c
where c.owner='&child_Owner'
  and c.table_name='&Child_Table_Name'
  and p.constraint_type IN ('P','U')
  and c.constraint_type='R' 
  and p.owner=c.r_owner
  and p.constraint_name=c.r_constraint_name
order by 4;


select 'alter table '||a.owner||'.'||a.table_name||' disable constraints '||a.constraint_name||';'
from dba_constraints a, dba_constraints b
where a.constraint_type='R' and a.r_constraint_name=b.constraint_name and a.r_owner=b.owner and a.owner='&OWNER' and b.table_name='&TABLE_NAME';

select 'alter table '||a.owner||'.'||a.table_name||' disable constraints '||a.constraint_name||';'
from dba_constraints a, dba_constraints b
where a.constraint_type='R' and a.r_constraint_name=b.constraint_name and a.r_owner=b.owner and a.owner='&OWNER' and a.status!='ENABLED';


select A.owner FK_T_OWNER,A.TABLE_NAME FK_T_NAME,A.CONSTRAINT_NAME FK_NAME,A.CONSTRAINT_TYPE,A.STATUS,B.OWNER RK_T_OWNER,B.TABLE_NAME RK_T_NAME,
A.R_CONSTRAINT_NAME RK_NAME,A.INDEX_OWNER,A.INDEX_NAME,A.INVALID FROM DBA_CONSTRAINTS A, dba_constraints b where a.constraint_name='R' and 
a.r_constraint_name=b.constraint_name and  a.r_owner=b.owner and a.owner='&OWNER' and b.table_name='&TABLE_NAME';

select owner,constraint_name,table_name,status,deferrable,validated,index_owner,index_name from DBA_CONSTRAINTS where CONSTRAINT_NAME='COMPETENCIES_PK';

col OWNER for a20
col CONSTRAINT_NAME for a30
col TABLE_NAME for a30
col R_OWNER for a15
col R_CONSTRAINT_NAME for a20
select OWNER,CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,R_OWNER,R_CONSTRAINT_NAME,STATUS,VALIDATED from dba_constraints where CONSTRAINT_NAME='&CONSTRAINT_NAME';


####################### RMAN JOB ######################################

set pages 200
set lines 300
col OUTPUT_BYTES_DISPLAY for a10
col input_bytes_display for a10
col time_taken_display for a20
col status for a10
Select (select instance_name from v$instance) DB_NAME, session_key,SESSION_RECID,  input_type, status, to_char(start_time,'yyyy-mm-dd hh24:mi') start_time,  
to_char(end_time,'yyyy-mm-dd hh24:mi')   end_time, input_bytes_display,  output_bytes_display, time_taken_display 
from v$rman_backup_job_details where start_time > sysdate - 8 order by session_key asc;

set pages 200
set lines 300
col OUTPUT_BYTES_DISPLAY for a10
col input_bytes_display for a10
col time_taken_display for a20
col status for a10
Select (select instance_name from v$instance) DB_NAME, session_key,  input_type, status, to_char(start_time,'yyyy-mm-dd hh24:mi') start_time,  
to_char(end_time,'yyyy-mm-dd hh24:mi')   end_time, input_bytes_display,  output_bytes_display,  time_taken_display 
from v$rman_backup_job_details where start_time > sysdate - 8 and input_type !='ARCHIVELOG' order by session_key asc;

To check the RMAN backup piece size :

SELECT TO_CHAR(completion_time, 'YYYY-MON-DD') completion_time, type, round(sum(bytes)/1048576) MB, round(sum(elapsed_seconds)/60) min
FROM
(
SELECT
CASE
  WHEN s.backup_type='L' THEN 'ARCHIVELOG'
  WHEN s.controlfile_included='YES' THEN 'CONTROLFILE'
  WHEN s.backup_type='D' AND s.incremental_level=0 THEN 'LEVEL0'
  WHEN s.backup_type='I' AND s.incremental_level=1 THEN 'LEVEL1'
END type,
TRUNC(s.completion_time) completion_time, p.bytes, s.elapsed_seconds
FROM v$backup_piece p, v$backup_set s
WHERE p.status='A' AND p.recid=s.recid 
UNION ALL
SELECT 'DATAFILECOPY' type, TRUNC(completion_time), output_bytes, 0 elapsed_seconds FROM v$backup_copy_details
)
GROUP BY TO_CHAR(completion_time, 'YYYY-MON-DD'), type
ORDER BY 1 ASC,2,3;

DB INCR
col STATUS format a10
col hrs format 999.99

select SESSION_KEY, INPUT_TYPE, STATUS,
to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,
elapsed_seconds/3600 hrs from V$RMAN_BACKUP_JOB_DETAILS
order by session_key;

set lines 220
set pages 1000
col cf for 9,999
col df for 9,999
col elapsed_seconds heading "ELAPSED|SECONDS"
col i0 for 9,999
col i1 for 9,999
col l for 9,999
col output_mbytes for 9,999,999 heading "OUTPUT|MBYTES"
col session_recid for 999999 heading "SESSION|RECID"
col session_stamp for 99999999999 heading "SESSION|STAMP"
col status for a10 trunc
col time_taken_display for a10 heading "TIME|TAKEN"
col output_instance for 9999 heading "OUT|INST"
select
j.session_recid, j.session_stamp,
to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time,
(j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type,
decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',
3, 'Tuesday', 4, 'Wednesday',
5, 'Thursday', 6, 'Friday',
7, 'Saturday') dow,
j.elapsed_seconds, j.time_taken_display,
x.cf, x.df, x.i0, x.i1, x.l,
ro.inst_id output_instance
from V$RMAN_BACKUP_JOB_DETAILS j
left outer join (select
d.session_recid, d.session_stamp,
sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF,
sum(case when d.controlfile_included = 'NO'
and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF,
sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0,
sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1,
sum(case when d.backup_type = 'L' then d.pieces else 0 end) L
from
V$BACKUP_SET_DETAILS d
join V$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
where s.input_file_scan_only = 'NO'
group by d.session_recid, d.session_stamp) x
on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp
left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id
from GV$RMAN_OUTPUT o
group by o.session_recid, o.session_stamp)
ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp
where j.start_time > trunc(sysdate)- 7
order by j.start_time;


set lines 200 pages 200
col name for a12
select * from v$flash_recovery_area_usage ;
SELECT Sum(percent_space_used)-Sum(percent_space_reclaimable) "PCT_SPACE_USED_NOT_FREEABLE" FROM v$flash_recovery_area_usage;
SELECT * FROM V$RECOVERY_FILE_DEST;
 
ALTER SYSTEM SET DB_RECOVERY_FILE_DEST_SIZE = 200G SCOPE=BOTH;

To see the running RMAN output from the views :
set lines 300
col STATUS format a22
col hrs format 999.99
select
SESSION_KEY, SESSION_RECID, SESSION_STAMP,INPUT_TYPE, STATUS,to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,
elapsed_seconds/3600 hrs from V$RMAN_BACKUP_JOB_DETAILS order by session_key;

Please enter  SESSION_RECID  and  SESSION_STAMP  from the 1st query mentioned in step 1.

set lines 200
set pages 1000
select output from GV$RMAN_OUTPUT where session_recid = &SESSION_RECID and session_stamp = &SESSION_STAMP order by recid;
 
set lines 200 pages 200
COL opname for a32
col start_time for a21
col Last_update_time for a21
select INST_ID,SID,SERIAL#,OPNAME,TO_CHAR(START_TIME,'DD-MON-YYYY HH24:MI:SS') START_TIME, TO_CHAR(LAST_UPDATE_TIME,'DD-MON-YYYY HH24:MI:SS') 
LAST_UPDATE_TIME , SOFAR,TOTALWORK,ROUND(SOFAR/TOTALWORK*100,2) "%COMPLETED" FROM GV$SESSION_LONGOPS WHERE OPNAME LIKE 'RMAN%' AND TOTALWORK!=0 AND SOFAR!=TOTALWORK ORDER BY 5;

set lines 200 pages 200
COL opname for a32
col start_time for a21
col Last_update_time for a21
select INST_ID,SID,SERIAL#,OPNAME,TO_CHAR(START_TIME,'DD-MON-YYYY HH24:MI:SS') START_TIME, TO_CHAR(LAST_UPDATE_TIME,'DD-MON-YYYY HH24:MI:SS') 
LAST_UPDATE_TIME , SOFAR,TOTALWORK,ROUND(SOFAR/TOTALWORK*100,2) "%COMPLETED" FROM GV$SESSION_LONGOPS WHERE TOTALWORK!=0 and OPNAME LIKE '%IMPORT%' ;
AND SOFAR!=TOTALWORK ORDER BY 5;
select INST_ID,SID,SERIAL#,OPNAME,TO_CHAR(START_TIME,'DD-MON-YYYY HH24:MI:SS') START_TIME, TO_CHAR(LAST_UPDATE_TIME,'DD-MON-YYYY HH24:MI:SS') 
LAST_UPDATE_TIME , SOFAR,TOTALWORK,ROUND(SOFAR/TOTALWORK*100,2) "%COMPLETED" FROM GV$SESSION_LONGOPS WHERE TOTALWORK!=0 and OPNAME LIKE '%EXPORT%' ;
AND SOFAR!=TOTALWORK ORDER BY 5;

COL START_TIME FOR A16
COL END_TIME FOR A16
COL IN_BYTES FOR A9
COL OP_BYTES FOR A9
COL PER_SEC FOR A9
COL TIME_TAKEN FOR A10
SELECT * FROM (SELECT SESSION_KEY KEY, INPUT_TYPE BACKUP_TYPE, OUTPUT_DEVICE_TYPE DEVICE_TYPE, TO_CHAR(START_TIME,'DD-MON-YYYY HH24:MI:SS') START_TIME,TO_CHAR(END_TIME,'DD-MON-YYYY HH24:MI:SS') END_TIME, STATUS, INPUT_BYTES_DISPLAY IN_BYTES , 
OUTPUT_BYTES_DISPLAY OP_BYTES, OUTPUT_BYTES_PER_SEC_DISPLAY PER_SEC, TIME_TAKEN_DISPLAY TIME_TAKEN FROM V$RMAN_BACKUP_JOB_DETAILS WHERE INPUT_TYPE LIKE '%&BACKUP_TYPE%' ORDER BY ROWNUM < 11 DESC ) WHERE ROWNUM < 11 ORDER BY KEY;

set pages 200
set lines 300
col OUTPUT_BYTES_DISPLAY for a10
col input_bytes_display for a10
col time_taken_display for a20
col status for a10
Select (select instance_name from v$instance) DB_NAME, session_key,  input_type, status, to_char(start_time,'yyyy-mm-dd hh24:mi') start_time,  
to_char(end_time,'yyyy-mm-dd hh24:mi')   end_time, input_bytes_display,  output_bytes_display,  time_taken_display 
from v$rman_backup_job_details where start_time> sysdate -1 order by session_key asc;

To check for the output write capacity : 

set pages 9999 lines 500
set numformat 99999.99
set trim on 
set trims on
alter session set nls_date_format = 'DD-MM-YYYY HH24:MI:SS';
col INSTANCE for a9
col status for a22
col COMMAND_ID for a20
col INPUT_TYPE for a10
col OUTPUT_DEVICE_TYPE for a10
col OUTPUT_BYTES_PER_SEC_DISPLAY for a9
col status heading "BACKUP|STATUS" for a10
col COMMAND_ID heading "BACKUP NAME" 
col STARTED_TIME heading "START TIME" 
COL END_TIME heading "END TIME" 
col ELAPSED_TIME heading "MINUTES | TAKEN" 
col INPUT_TYPE heading "INPUT|TYPE" 
col OUTPUT_DEVICE_TYPE heading "OUTPUT|DEVICES" 
col INPUT_SIZE heading  "INPUT SIZE|GB"
col OUTPUT_SIZE heading  "OUTPUT SIZE|GB" 
col OUTPUT_BYTES_PER_SEC_DISPLAY heading "OUTPUT | RATE|(PER SEC)"
SELECT (SELECT instance_name FROM v$instance) || ' ' || (SELECT instance_number FROM v$instance) instance,rs.sid,
rj.COMMAND_ID,
rj.STATUS,
max(rj.START_TIME) STARTED_TIME, 
rj.END_TIME,
rj.ELAPSED_SECONDS/60 ELAPSED_TIME,
rj.INPUT_TYPE,
rj.OUTPUT_DEVICE_TYPE,
rj.INPUT_BYTES/1024/1024/1024 INPUT_SIZE, 
rj.OUTPUT_BYTES/1024/1024/1024 OUTPUT_SIZE,
rj.OUTPUT_BYTES_PER_SEC_DISPLAY,
rj.output_bytes_per_sec/1024/1024 output_bytes_per_sec
from v$rman_backup_job_details rj, v$rman_status rs
where rj.COMMAND_ID=rs.COMMAND_ID
group by rs.sid,rj.COMMAND_ID,rj.STATUS,rj.START_TIME,rj.END_TIME,rj.ELAPSED_SECONDS,rj.INPUT_TYPE,rj.OUTPUT_DEVICE_TYPE,rj.INPUT_BYTES,rj.OUTPUT_BYTES,
rj.OUTPUT_BYTES_PER_SEC_DISPLAY ,rj.output_bytes_per_sec
having max(rj.START_TIME) > sysdate-&NUMBER_OF_DAYS order by rj.START_TIME desc
/

SYNC IO:

COL DEVICE FOR A9
COL FILENAME FOR A50
SELECT A.DEVICE_TYPE DEVICE, A.TYPE, B.STATUS, B.MBYTES_PROCESSED AS "TOTAL_MB",A.FILENAME,ROUND(A.BYTES/(1024*1024)) AS "SIZE_MB",
TO_CHAR(A.OPEN_TIME,'DD-MON-YYYY HH24:MI:SS') AS OPEN_TIME,ROUND(A.ELAPSED_TIME/100) AS "TIME(S)", ROUND(A.EFFECTIVE_BYTES_PER_SECOND/(1024*1024)) AS "MB/SEC"
FROM V$BACKUP_SYNC_IO A, V$RMAN_STATUS B WHERE A.RMAN_STATUS_RECID = B.RECID AND A.OPEN_TIME > SYSDATE - 7 ORDER BY A.USE_COUNT;

STEP 3: Check the logs or output of the running RMAN jobs 
set lines 200
set pages 1000
select output from GV$RMAN_OUTPUT where session_recid = &SESSION_RECID and session_stamp = &SESSION_STAMP order by recid;


ASYNC IO:

COL DEVICE FOR A9
COL FILENAME FOR A50
SELECT A.DEVICE_TYPE DEVICE, A.TYPE, B.STATUS, B.MBYTES_PROCESSED AS "TOTAL_MB",A.FILENAME,ROUND(A.BYTES/(1024*1024)) AS "SIZE_MB",
TO_CHAR(A.OPEN_TIME,'DD-MON-YYYY HH24:MI:SS') AS OPEN_TIME,ROUND(A.ELAPSED_TIME/100) AS "TIME(S)", ROUND(A.EFFECTIVE_BYTES_PER_SECOND/(1024*1024)) AS "MB/SEC"
FROM V$BACKUP_ASYNC_IO A, V$RMAN_STATUS B WHERE A.RMAN_STATUS_RECID = B.RECID AND A.OPEN_TIME > SYSDATE - 7 ORDER BY A.USE_COUNT;

SHOW PARAMETER FILESYSTEMIO_OPTIONS

cat /proc/slabinfo | grep kio

RMAN Duplicate Database Having Multiple Directories to Assign to BACKUP LOCATION (Doc ID 1606004.1)
backup as compressed backupset archivelog all delete input;
backup archivelog all delete input;
BACKUP ARCHIVELOG UNTIL 'trunc(sysdate-1)' DELETE INPUT;
BACKUP ARCHIVELOG UNTIL 'trunc(sysdate-3)' DELETE INPUT;
BACKUP ARCHIVELOG FROM TIME 'SYSDATE-7' UNTIL TIME 'SYSDATE' DELETE INPUT;
crosscheck archivelog all;
delete expired archivelog all;
RMAN>BACKUP RECOVERY AREA;
DELETE backup of ARCHIVELOG ALL COMPLETED BEFORE 'sysdate-3';
DELETE ARCHIVELOG ALL COMPLETED BEFORE 'sysdate-7';
delete archivelog UNTIL TIME = 'SYSDATE-23/24' backed up 1 times ;
delete archivelog until sequence 2200;
delete force archivelog until sequence 6828;
To restore the archivelog to different location :
run
{
set archivelog destination to '/oracle/stage';
restore archivelog from logseq=190385 until logseq=190387;
}

list backup of archivelog from sequence 22053 until 22494 thead 1;
list backup of archivelog from sequence 10167 until 10349 thead 2;
delete backup completed before 'sysdate-8';
report 
CATALOG ARCHIVELOG '?/oradata/archive1_30.dbf', '?/oradata/archive1_31.dbf', '?/oradata/archive1_32.dbf';
CATALOG DATAFILECOPY ‘?/oracle/oradata/data01.dbf’ LEVEL 0;
CATALOG BACKUPPIECE ‘/u01/bkp/rman/KOKTSV_ORCL_RMAN_ONL_ST’;
RMAN> RESET DATABASE TO INCARNATION 3;

If we need to catalog multiple archivelog or backup piece for some pattern then use below command
[oracle@test ~] echo > catalog.rcv for archivelog in /u01/test/arch/CPROD_LEV0* ; do echo "catalog archivelog '$archivelog';" >> catalog.rcv done
[oracle@test ~] Rman target / cmdfile=catalog.rcv

Trobulshooting RMAN backup performance issue :
Script to monitor RMAN Backup and Restore Operations (Doc ID 1487262.1)
Advise On How To Improve Rman Performance (Doc ID 579158.1)
RMAN Performance Troubleshooting (Doc ID 1326686.1)
RMAN: Monitoring Recovery Manager Jobs (Doc ID 144640.1)

	
select device_type "Device", type, filename, to_char(open_time, 'mm/dd/yyyy hh24:mi:ss') open,
to_char(close_time,'mm/dd/yyyy hh24:mi:ss') close,elapsed_time ET, effective_bytes_per_second EPS
from v$backup_async_io
where close_time > sysdate - 30
order by close_time desc;

select * from (select io_count, ready, short_waits, long_waits, long_waits/io_count, filename,to_char(open_time, 'mm/dd/yyyy hh24:mi:ss') OPEN,to_char(close_time, 'mm/dd/yyyy hh24:mi:ss') CLOSE from v$backup_async_io order by close_time desc ) where rownum < 10;
where close_time > sysdate - 30
order by close_time desc;
----------
RMAN Duplicate :
----------------
nohup sh uatclone_rmanscript.sh > dbuatclone_rman_03JUN22.log &

cat uatclone_rmanscript.sh

$ORACLE_HOME/bin/rman <<EOF
connect target sys/sq7_GH65_pl9@//10.150.40.18:1521/EQPRDc_syd18x
connect auxiliary sys/sq7_GH65_pl9
run{
allocate channel src1 type disk;
allocate channel src2 type disk;
allocate auxiliary channel aux1 type disk;
allocate auxiliary channel aux2 type disk;
allocate auxiliary channel aux3 type disk;
allocate auxiliary channel aux4 type disk;
duplicate target database to 'EQDEV2C' from active database nofilenamecheck;
}
EOF



RMAN backup script :
---------------------
[oracle@qbepinfdb011 CS0508742]$ cat full_backup_v1.sh
export DATE=$(date +%y-%m-%d_%H%M%S)

rman target / log=/home/oracle/inodba/logs/proddb_${DATE}.log << EOF
RUN {
ALLOCATE CHANNEL c1 DEVICE TYPE disk;
ALLOCATE CHANNEL c2 DEVICE TYPE disk;
ALLOCATE CHANNEL c3 DEVICE TYPE disk;
ALLOCATE CHANNEL c4 DEVICE TYPE disk;
CONFIGURE DEVICE TYPE DISK PARALLELISM 4 BACKUP TYPE TO BACKUPSET;
BACKUP FULL FORMAT '/mnt/qbe-prd-dmp/PQBEIT/CS0508742/%d_%U' DATABASE INCLUDE CURRENT CONTROLFILE PLUS ARCHIVELOG;
RELEASE CHANNEL c1;
RELEASE CHANNEL c2;
RELEASE CHANNEL c3;
RELEASE CHANNEL c4;
}
EOF


alter system set db_recovery_file_dest='+RECO' SCOPE=BOTH;
alter system set log_archive_dest_1='location=USE_DB_RECOVERY_FILE_DEST' SCOPE=BOTH;

Cloud backup check logs :
jobs logs will be here : /opt/oracle/dcs/log/jobs
Rman logs will be here :
/opt/oracle/dcs/log/qbe1ebsdb011/rman/bkup/DQBEIIc_syd1ch/rman_backup_Auto_Archive_2023-08-23_02-03-14-4618609863694478050.log


Script To Set Newname For Datafiles Restore  :
-- Source Server --

set head off pages 0 feed off echo off verify off
set lines 200
spool rename_datafiles.sql
select 'set newname for datafile ' || file_id || ' to ''/san/data/' ||
substr(file_name,instr(file_name,'/',-1)+1) || ''';'
from dba_data_files ;
spool off
-- on Target Server --
sqlplus "/as sysdba"
set head off pages 0 feed off echo off verify off
set lines 200
spool rename_datafiles.sql
select 'set newname for datafile ' || file# || ' to ''/san/data/' ||
substr(name,instr(name,'/',-1)+1) || ''';'
from v$datafile ;
spool off

Block change tracking :
=======================
SELECT * FROM V$BLOCK_CHANGE_TRACKING;
ALTER DATABASE ENABLE BLOCK CHANGE TRACKING;
ALTER DATABASE ENABLE BLOCK CHANGE TRACKING USING FILE '/u02/rman/rman_change_track.f';
ALTER DATABASE ENABLE BLOCK CHANGE TRACKING USING FILE '/u02/rman/rman_change_track.f' REUSE;
ALTER DATABASE DISABLE BLOCK CHANGE TRACKING; 

####################### TDE / Encryption wallet

set lines 200 pages 200
col wrl_parameter for a30
col wrl_parameter for a30
col status for a6
col WRL_TYPE for a12
col WALLET_TYPE for a15
select * from gv$encryption_wallet;


set lines 200 pages 200
col WALLET_DIR for a60
col STATUS for a15
select CON_ID,STATUS,WRL_PARAMETER WALLET_DIR,WALLET_TYPE from V$ENCRYPTION_WALLET;
select con_id, mkloc from x$kcbdbk;
ALTER SYSTEM SET ENCRYPTION WALLET OPEN IDENTIFIED BY "Gcxhsg#hshY";

srvctl setenv database -d NAS1EBSc_syd1hz -T "TNS_ADMIN=/u01/app/oracle/product/19.0.0.0/dbhome_1/network/admin"
srvctl setenv database -d NAS1EBSc_syd1hz -T "ORACLE_UNQNAME=NAS1EBSc_syd1hz"
srvctl getenv database -d NAS1EBSc_syd1hz 

Creating the secure user credential in the wallet : 
http://www.br8dba.com/store-db-credentials-in-oracle-wallet/
https://virtual-dba.com/blog/oracle-create-a-wallet-store-secure-user-credentials-for-rman/
mkstore -wrl /u01/admin/BSA1EP/wallet -createCredential BSA1EP test
mkstore -wrl /u01/admin/BSA1EP/wallet -listCredential
mkstore -wrl /u01/admin/BSA1EP/wallet -modifyCredential BSA1EP test test999

Certificate check :
===================
orapki wallet display -wallet "/u01/appx/fusion_wallet"
orapki cert display -cert DigiCert_Global_Root_G2.crt

Add certificate to wallet :
---------------------------
To see the end date of wallet :
openssl x509 -in DigiCert_Global_Root_G2.crt -noout -enddate

To take the backup of the wallet :
cp -R /u01/appx/fusion_wallet /u01/appx/fusion_wallet_backup

To create the wallet :
orapki wallet create -wallet /u01/appx/fusion_wallet -auto_login -pwd jhg_6578fd5H_GIDS_i6fh

Add certificate to the wallet :
orapki wallet add -wallet /u01/appx/fusion_wallet -trusted_cert -cert /tmp/DigiCert_Global_Root_G2.crt


alter session set current_schema = SYSADM;

SELECT utl_http.request('https://eehj-test.fa.us2.oraclecloud.com/finApInvQuickInvoicesModel/InvoiceInterfaceService?WSDL', null, 'file:/u01/appx/fusion_wallet')
FROM dual;

https://eblk.fa.em2.oraclecloud.com/fscmUI
Few information for the certificate :
 Fusion SaaS SSL Certificate Renewal (Doc ID 2676283.1)
Please record this information somewhere as this should be a known fix to managed services. It has been done many times and every time I am asked to get involved, despite us having supported these builds for 9 years.
Here are the instructions.
Login to the target Fusion environment. (https://eehj-test.fa.us2.oraclecloud.com/)
Depending on the browser, click the padlock or site information icon to the left of the URL.
Navigate to the certificate information.
You will see the full certificate chain (root, intermediate and site).
We should only need the root certificate, earlier versions of the database required the full chain.
Export the root certificate, load it to the wallet and test.
We use the certificates in our oracle wallet to make the HTTPS calls for the various API’s.
Each instance has a certificate chain consisting of Root > Intermediate > Site level certificates.
We only use the root certificate in our wallet.
The Oracle support note states that only the site level certificate was to be updated so I am really not sure what has gone on on test.
I have checked the current prod root cert and it is fine.
To be on the safe side we could add the new root cert that we put on test into the prod wallet. Even though right now it is not required.

############## SESSION INFO :

set lines 200 pages 200

COL INST FOR 999
COL USERNAME FOR A15
COL OSUSER FOR A10
COL MACHINE FOR A20
COL PROGRAM FOR A22
COL LOGON_TIME FOR A20
COL CLIENT_IDENTIFIER for a20
SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS') LOGON_TIME , LAST_CALL_ET FROM GV$SESSION 
WHERE USERNAME like '%&USERNAME%' ORDER BY LAST_CALL_ET;

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS') LOGON_TIME , LAST_CALL_ET FROM GV$SESSION 
WHERE CLIENT_IDENTIFIER like '%&USERNAME%' ORDER BY LAST_CALL_ET;
WHERE last_call_et > (60*60*24)

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID,PREV_SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS') LOGON_TIME , LAST_CALL_ET FROM GV$SESSION 
WHERE OSUSER like '%&USERNAME%' ORDER BY LAST_CALL_ET;
 
SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET FROM GV$SESSION WHERE PADDR IN (SELECT ADDR FROM V$PROCESS WHERE SPID='&SPID');

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM,MODULE, SQL_ID,PREV_SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET FROM GV$SESSION WHERE SID IN ('&SID');

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET FROM GV$SESSION WHERE BLOCKING_SESSION IS NOT NULL;

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET FROM GV$SESSION WHERE SID IN (SELECT BLOCKING_SESSION FROM GV$SESSION);

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET FROM GV$SESSION WHERE USERNAME IS NOT NULL AND USERNAME NOT IN ('SYS','DBSNMP','SYSTEM') ORDER BY LAST_CALL_ET;

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET , CLIENT_IDENTIFIER FROM GV$SESSION WHERE USERNAME='&USERNAME';

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET , CLIENT_IDENTIFIER FROM GV$SESSION WHERE status='INACTIVE' and program like '%frmweb%' order by logon_time; 

SELECT INST_ID INST,USERNAME,MACHINE,STATUS,COUNT(*) FROM GV$SESSION WHERE USERNAME IS NOT NULL AND USERNAME NOT IN ('SYS','SYSTEM') GROUP BY 
INST_ID, USERNAME, MACHINE,STATUS ORDER BY 1,5;

SELECT INST_ID INST,USERNAME,MACHINE,STATUS,PROGRAM, COUNT(*) FROM GV$SESSION WHERE USERNAME IS NOT NULL AND USERNAME NOT IN ('SYS','SYSTEM') GROUP BY 
INST_ID, USERNAME, MACHINE,STATUS,PROGRAM ORDER BY 1,5;

SELECT INST_ID INST,USERNAME,MACHINE,STATUS,COUNT(*) FROM GV$SESSION GROUP BY INST_ID, USERNAME, MACHINE,STATUS ORDER BY 1,5;
SELECT VS.SID,VS.SERIAL#,VS.USERNAME,VS.INST_ID,VP.SPID FROM GV$SESSION VS, GV$PROCESS VP WHERE VS.PADDR=VP.ADDR AND VS.SID ='&SID';

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, 
SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS') LOGON_TIME , LAST_CALL_ET FROM GV$SESSION WHERE SID IN ('&SID');

SELECT A.SID,A.SERIAL#,C.SPID,A.USERNAME,A.MACHINE,A.PROGRAM,B.SQL_FULLTEXT FROM V$SESSION A, V$PROCESS C, V$SQL B  WHERE A.PADDR = C.ADDR AND
A.SQL_ID=B.SQL_ID AND C.SPID IN ('61935');
SELECT A.SID,A.SERIAL#,C.SPID,A.USERNAME,A.MACHINE,A.PROGRAM,B.SQL_FULLTEXT FROM gV$SESSION A, gV$PROCESS C, gV$SQL B  WHERE A.PADDR = C.ADDR AND
A.SQL_ID=B.SQL_ID AND C.SPID IN ('65131');

select B.SQL_FULLTEXT from  V$SQL B WHERE B.SQL_ID='&SQL_ID';
select B.SQL_TEXT from dba_hist_sqltext B WHERE B.SQL_ID='&SQL_ID';
select B.SQL_ID from dba_hist_sqltext B WHERE B.SQL_TEXT like '%&SQL_TEXT%';

SELECT QCSID "QUERY COORDINATOR" ,COUNT(*) AS "SLAVES COUNT" FROM GV$PX_SESSION GROUP BY QCSID;

SELECT 'ALTER SYSTEM KILL SESSION '''||SID ||','||SERIAL#||''' IMMEDIATE;' FROM V$SESSION WHERE USERNAME='&USENAME';
SELECT 'ALTER SYSTEM KILL SESSION '''||SID ||','||SERIAL#||''' IMMEDIATE;' FROM V$SESSION WHERE status='INACTIVE' and program like '%frmweb%' order by logon_time; 

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID,PREV_SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS') LOGON_TIME , LAST_CALL_ET FROM GV$SESSION 
WHERE USERNAME='EMUSER' AND status = 'INACTIVE' and MACHINE='qbepctlmt02.qbeprodapp.vcnqbeprd.oraclevcn.com' order by 1;

SELECT 'ALTER SYSTEM KILL SESSION '''||SID||','||SERIAL#|| ',@'||INST_ID ||''' IMMEDIATE ;' FROM GV$SESSION 
WHERE USERNAME='EMUSER' and last_call_et > (60*60*24) AND status = 'INACTIVE' order by 1;

SELECT 'ALTER SYSTEM KILL SESSION '''||SID||','||SERIAL#|| ',@'||INST_ID ||''' IMMEDIATE ;' FROM GV$SESSION WHERE sql_id ='dnfckgz7bjkqc';

select 'ALTER SYSTEM DISCONNECT SESSION "' || s.sid || ',' || s.serial# || '" IMMEDIATE;' FROM v$session s WHERE s.last_call_et > (60*60*24)
AND rownum < 200 AND status = 'INACTIVE' order by 1;

DISTRIBUTED TRANSACTION :
The following query can be used to identify the session started by a distributed transaction

select username, osuser, status, sid, serial#, machine, process, terminal, program from v$session where saddr in (select k2gtdses from sys.x$k2gte );
 
The fixed table x$k2gte contains 2PC Global Transaction Entry. The column k2gtdses in x$k2gte has the session state object and this can be mapped to the saddr column of v$session.

###########RESOURCE LIMIT


COL RESOURCE_NAME FOR A20
COL INITIAL_ALLOCATION FOR A18
COL LIMIT_VALUE FOR A11
SELECT INST_ID INST, RESOURCE_NAME, CURRENT_UTILIZATION, MAX_UTILIZATION, INITIAL_ALLOCATION, LIMIT_VALUE FROM GV$RESOURCE_LIMIT WHERE RESOURCE_NAME 
IN ('PROCESSES','SESSIONS');

select * from DBA_HIST_RESOURCE_LIMIT where resource_name in ('sessions','processes');

col snapshottime for a20
col resource_name for a20
select s.SNAP_ID,TO_CHAR(s.END_INTERVAL_TIME, 'DD-MON HH24:MI:SS') Snapshottime,resource_name,current_utilization,max_utilization,limit_value 
from DBA_HIST_SNAPSHOT s, DBA_HIST_RESOURCE_LIMIT b
where s.snap_id = b.snap_id and resource_name in ('sessions') order by 2;

col snapshottime for a20
col resource_name for a20
select s.SNAP_ID,TO_CHAR(s.END_INTERVAL_TIME, 'DD-MON HH24:MI:SS') Snapshottime,resource_name,current_utilization,max_utilization,limit_value 
from DBA_HIST_SNAPSHOT s, DBA_HIST_RESOURCE_LIMIT b
where s.snap_id = b.snap_id and resource_name in ('sessions') and current_utilization > 600 order by 2;

select s.SNAP_ID , TO_CHAR(s.BEGIN_INTERVAL_TIME, 'DD-MON HH24:MI:SS'), TO_CHAR(s.END_INTERVAL_TIME, 'DD-MON HH24:MI:SS') Snapshottime from DBA_HIST_SNAPSHOT s where rownum < 10 order by 1 desc;


#############WAIT EVENT

select inst_id,event,count(*) from gv$session group by inst_id, event order by 1,3;

col event for a30
select inst_id inst, sid, serial#,username,status,blocking_session blocker,event,osuser,machine,sql_id,to_char(logon_time,'dd-mon-yyyy hh24:mi:ss'),
logon_time, last_call_et from gv$session where event like '%&event%' order by last_call_et;

select dbs.sid holding_sid, dbs.serial# holding_serial#, dbs.username holding_user, 
       (select count(sid) from v$session where blocking_session = dbs.sid) sessions_blocked,
       dbs.sql_id holding_sql_id, dbs.wait_class holding_class, dbs.event holding_event, dbs.seconds_in_wait holding_secs, 
       dws.sid waiting_sid, dws.serial# waiting_serial#, dws.username waiting_user, dws.sql_id waiting_sql_id, dws.wait_class waiting_class, dws.event waiting_event, dws.seconds_in_wait waiting_secs
from gv$session dbs, gv$session dws
where dws.blocking_session = dbs.sid
order by dbs.sid, dws.seconds_in_wait desc
/


##############TRACE FILE NAME

##############CHECK SEGMENT AND LOB SEGMENT SIZE_MB
set lines 200 pages 200
col TABLE_NAME for a20
col COLUMN_NAME for a20
col INDEX_NAME for a20
col SEGMENT_NAME for a 20
col SEGMENT_NAME for a20
select OWNER,TABLE_NAME,COLUMN_NAME,SEGMENT_NAME,TABLESPACE_NAME,INDEX_NAME,DEDUPLICATION,PARTITIONED,SECUREFILE,RETENTION_TYPE,RETENTION_VALUE from dba_lobs where SEGMENT_NAME='&SEGMENT_NAME';

set serveroutput on
declare
v_segment_size_blocks number;
v_segment_size_bytes number;
v_used_blocks number;
v_used_bytes number;
v_expired_blocks number;
v_expired_bytes number;
v_unexpired_blocks number;
v_unexpired_bytes number;
begin
dbms_space.space_usage ('&OWNER', '&securefile_SEGMENT_NAME', 'LOB', v_segment_size_blocks, v_segment_size_bytes, v_used_blocks, v_used_bytes, v_expired_blocks, v_expired_bytes, v_unexpired_blocks, v_unexpired_bytes);
dbms_output.put_line('Segment size in blocks = '||v_segment_size_blocks);
dbms_output.put_line('Used Blocks = '||v_used_blocks);
dbms_output.put_line('Expired Blocks = '||v_expired_blocks);
dbms_output.put_line('Unxpired Blocks = '||v_unexpired_blocks);
end;
/


select sum(dbms_lob.getchunksize(&column_name))/1024/1024/1024 from &table_name;

select sum(bytes)/1024/1024/1024 size_in_gb from dba_segments where owner='&owner' and segment_name = '&segment_name'; 
select owner,segment_name, sum(bytes)/1024/1024/1024 size_in_gb from dba_segments where owner='&owner' and segment_name in ('&segment_name1','&segment_name2') group by owner,segment_name ; 
select owner, sum(bytes)/1024/1024/1024 size_in_gb from dba_segments where owner in ('&OWNER1','&OWNER2') group by owner;

select owner, sum(bytes)/1024/1024/1024 size_in_gb from dba_segments where owner in ('INOAPPS_COMMON','MACE,MACE_REPORTING','PRODUCT_CIS') group by owner;

select sum(bytes)/1024/1024/1024 size_in_gb from dba_segments where segment_name in (select segment_name from dba_lobs where owner='&owner');

select sum(bytes)/1024/1024/1024 gb from dba_segments 
where (owner = '&table_owner' and segment_name = '&TABLE_NAME')
OR (owner,segment_name) in (select owner,segment_name from dba_lobs where owner='&TABLE_OWNER' and table_name = '&TABLE_NAME');


How to Determine what storage is used in a LOBSEGMENT and should it be shrunk / reorganized? (Doc ID 1453350.1)
NOTE:1394613.1 - How to Shrink a Securefile LOB Using Online Redefinition (DBMS_REDEFINITION)?
NOTE:1451124.1 - How to Shrink (make less sparse) a LOB (BASICFILE or SECUREFILE)?
NOTE:820043.1 - Why is no space released after an ALTER TABLE ... SHRINK?
How to determine the actual size of the LOB segments and how to free the deleted/unused space above/below the HWM (Doc ID 386341.1)

############### TOP SEGMENT BY SIZE

col owner for a15
col segment_name for a35
col tablespace_name for a20
select owner,segment_name,segment_type,tablespace_name,round(sum(bytes)/1024/1024/1024,2) SIZE_IN_GB 
from DBA_SEGMENTS
where BYTES/1024/1024/1024 > 5
group by owner,segment_name,segment_type,tablespace_name
order by owner,round(sum(bytes)/1024/1024/1024,2);

select owner,tablespace_name, sum(bytes)/1024/1024/1024 size_in_gb from dba_segments where owner in ('&OWNER1','&OWNER2') group by owner,tablespace_name;
select owner,tablespace_name, sum(bytes)/1024/1024/1024 size_in_gb from dba_segments where owner in ('SIPR') group by owner,tablespace_name;

col owner for a15
col segment_name for a35
col tablespace_name for a20
select owner,segment_name,segment_type,tablespace_name,round(sum(bytes)/1024/1024/1024,2) SIZE_IN_GB 
from DBA_SEGMENTS
-- where BYTES/1024/1024/1024 > 5 and 
where tablespace_name='&TABLESPACE_NAME'
group by owner,segment_name,segment_type,tablespace_name
order by owner,round(sum(bytes)/1024/1024/1024,2);


############## SYSAUX OCCUPANTS
set lines 200 pages 200
COL occupant_name for a30
col schema_name for a20
col move_procedure for a40
select occupant_name,round(space_usage_KBYTES/1024) "Space(M)", SCHEMA_NAME,MOVE_PROCEDURE FROM v$sysaux_occupants order by 2;

col begin_interval_time for a26
col end_interval_time for a26
select snap_id, begin_interval_time, end_interval_time from sys.wrm$_SNAPSHOT WHERE SNAP_ID = (SELECT MIN(SNAP_ID) FROM SYS.WRM$_SNAPSHOT)
UNION
SELECT SNAP_ID,BEGIN_INTERVAL_TIME,END_INTERVAL_TIME FROM SYS.WRM$_SNAPSHOT WHERE SNAP_ID = (SELECT MAX(SNAP_ID) FROM SYS.WRM$_SNAPSHOT);

BEGIN
	dbms_workload_repository.drop_snapshot_range(low_snap_id=> 700000, high_snap_id=>700000)
end;
/

################## Table Fragmentation

select t.owner,t.table_name,t.total_mb,t.fragmented_mb,t.actual_size,round((t.fragmented_mb/t.total_mb)*100,2) "Reclaimable_%" 
from (select owner,table_name,round((blocks*8)/1024,2) total_mb,round((num_rows*avg_row_len/1024/1024),2) actual_size,
round((blocks*8)/1024) - (num_row*avg_row_len)/1024/1024/1024) fragmented_mb,
from dba_tables where owner='&owner' and table_name='&table_name' ) t;

select owner,table_name,round((blocks*8)/1024,2) "size_in_mb",
round((num_rows*avg_row_len/1024/1024),2) "actual_data_mb",
(round((blocks*8)/1024,2) - round((num_row*avg_row_len/1024/1024),2)) "wasted_space_mb"
from dba_tables
where owner='&owner' and table_name='&table_name';


################ Check registory and invalid objects

set pages 1000 lines 200
col Action_name for a30
col action for a16
col namespace for a15
col version for a10
col comments for a40
select * from registry$history;

cd $ORACLE_HOME/OPatch

./datapatch -verbose

set serverout on
exec dbms_qopatch.get_sqlpatch_status;

col comp_id for a10
col comp_name for a40
col version for a15
col status for a10
select comp_id,comp_name,version,status,modified,namespace from dba_registry;

select count(*) from dba_objects where status='INVALID';

select owner,count(*) from dba_objects where status='INVALID' group by owner order by 1;

select owner,object_type,status, count(*) from dba_objects where status='INVALID' group by owner,object_type,status order by owner,object_type,status;
set lines 200 pages 200
col owner for a20
col object_name for a30
select owner,object_type, count(*) from dba_objects group by owner,object_type order by owner,object_type;
select owner,object_type, count(*) from dba_objects where owner='&OWNER' group by owner,object_type order by owner,object_type;
select owner,object_type, count(*) from dba_objects where ORACLE_MAINTAINED='N' group by owner,object_type order by owner,object_type;

col owner for a20
col object_name for a30
col created for a18desc 
col last_ddl_time for a18
select owner,object_name,object_type,status,to_char(created,'dd-mon-yyyy hh24:mi') CREATED,to_char(LAST_DDL_TIME,'DD-MON-YYYY HH24:MI') LAST_DDL_TIME
From dba_objects where status='INVALID' order by owner;

set lines 200 pages 200
col owner for a20
col object_name for a30
col created for a18
col LAST_DDL_TIME for a18
select owner,object_name,object_type,status,to_char(created,'dd-mon-yyyy HH24:MI') CREATED, to_char(LAST_DDL_TIME,'DD-MON-YYYY HH24:MI') LAST_DDL_TIME from DBA_OBJECTS where object_name='&OBJECT_NAME' order by owner;
 --   from DBA_OBJECTS where object_name like '%&OBJECT_NAME%' order by owner;
col owner for a20
col object_name for a30
col created for a18
col LAST_DDL_TIME for a18
select owner,object_name,object_type,status,to_char(created,'dd-mon-yyyy HH24:MI') CREATED, to_char(LAST_DDL_TIME,'DD-MON-YYYY HH24:MI') LAST_DDL_TIME
from DBA_OBJECTS where owner='&OWNER' order by owner,object_name,object_type;

col owner for a20
col synonym_name for a30
col table_owner for a20
col table_name for a30
col DB_LINK for a30
select owner, synonym_name,table_owner,table_name,db_link from dba_synonyms where table_owner='&OWNER';

select 'alter '||OBJECT_TYPE||' '||OWNER||'.'||OBJECT_NAME||' COMPILE;' FROM DBA_OBJECTS where STATUS='INVALID' AND OWNER NOT IN ('PUBLIC');
select 'alter '||OBJECT_TYPE||' '||OWNER||'.'||OBJECT_NAME||' COMPILE;' FROM DBA_OBJECTS where STATUS ='INVALID' AND OWNER IN ('DCES_FRANCE');

SELECT 'ALTER PUBLIC SYNONYMS '||OBJECT_NAME||' COMPILE;' FROM DBA_OBJECTS WHERE STATUS='INVALID' AND OWNER='PUBLIC' AND OBJECT_TYPE='SYNONYM';

Sequence :
SELECT SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, INCREMENT_BY, CYCLE_FLAG, CACHE_SIZE, LAST_NUMBER, SESSION_FLAG, KEEP_VALUE FROM USER_SEQUENCES WHERE SEQUENCE_NAME = 'EMP_TEST_SEQ_CLAUSES';

################### TABLE PARTATIONS

COL OWNER FOR A20
COL TABLE_NAME FOR a30
col partitioned for a11
col LOGGING for a7
col CREATED for a18
col LAST_DDL_TIME for a18
col LAST_ANALYZED FOR A18
SELECT DT.OWNER,DT.TABLE_NAME,DT.PARTITIONED,DT.NUM_ROWS "ROWS", DT.MONITORING,,DT.LOGGING,TO_CHAR(DO.CREATED,'DD-MON-YYYY HH24:MI') CREATED,
TO_CHAR(DO.LAST_DDL_TIME,'DD-MON-YYYY HH24:MI') LAST_DDL_TIME,TO_CHAR(DT.LAST_ANALYZED,'DD-MON-YYYY HH24:MI') LAST_ANALYZED FROM DBA_TABLES DT,
DBA_OBJECTS DO WHERE DT.OWNER=DO.OWNER AND DT.TABLE_NAME=DO.OBJECT_NAME AND 
DO.OBJECT_TYPE='TABLE' AND DT.TABLE_NAME='&TABLE_NAME';
,TO_CHAR(DT.LAST_ANALYZED,'DD-MON-YYYY HH24:MI') LAST_ANALYZED FROM DBA_TABLES DT;


COL TABLE_OWNER FOR A15
COL TABLE_NAME FOR A20
COL PARTITION_NAME FOR A15
COL HIGH_VALUE FOR A32
COL TABLESPACE_NAME FOR A15
SELECT TABLE_OWNER,TABLE_NAME,PARTITION_NAME,SUBPARTITION_COUNT SUB_PART, HIGH_VALUE,TABLESPACE_NAME,LAST_ANALYZED FROM DBA_TAB_PARTITIONS WHERE
TABLE_NAME='&TABLE_NAME';

COL TABLE_OWNER FOR A15
COL TABLE_NAME FOR A15
COL PARTITION_NAME FOR A15
COL TABLESPACE_NAME FOR A15
COL HIGH_VALUE FOR A10
SELECT TABLE_OWNER,TABLE_NAME,PARTITION_NAME,SUBPARTITION_NAME, HIGH_VALUE,TABLESPACE_NAME,LAST_ANALYZED FROM DBA_TAB_SUBPARTITIONS WHERE 
TABLE_NAME='&TABLE_NAME';


##################### INDEX 
COL OWNER FOR A15
COL INDEX_OWNER FOR A15
COL INDEX_NAME FOR A25
COL TABLE_OWNER FOR A15
COL TABLE_NAME FOR A25
COL PARTITIONED FOR A32
COL LOGGING FOR A3
COL BLEVEL FOR A999
COL DEGREE FOR A6
COL CREATED FOR A16
COL LAST_DDL_TIME FOR A16
COL LAST_ANALYZED FOR A16
SELECT DI.OWNER, DI.INDEX_NAME,DI.PARTITIONED,DI.TABLE_OWNER,DI.TABLE_NAME,DI.UNIQUENESS,DI.LOGGING,DI.BLEVEL,DI.DEGREE,DI.STATUS,
TO_CHAR(DO.CREATED,'dd-mon-yyyy hh24:mi') CREATED,to_char(DO.LAST_DDL_TIME,'DD-MON-YYYY HH24:MI') LAST_DDL_TIME,TO_CHAR(DI.LAST_ANALYZED,'DD-MON-YYYY HH24:MI') LAST_ANALYZED
FROM DBA_INDEXES DI,DBA_OBJECTS DO WHERE DI.OWNER=DO.OWNER AND DI.INDEX_NAME=DO.OBJECT_NAME AND DO.OBJECT_TYPE='INDEX' AND DI.TABLE_NAME='&TABLE_NAME'
ORDER BY DI.TABLE_OWNER;

COL INDEX_OWNER FOR A25
COL INDEX_NAME FOR A25
COL TABLE_OWNER FOR A15
COL TABLE_NAME FOR A25
COL COLUMN_NAME FOR A25
SELECT INDEX_OWNER,INDEX_NAME,TABLE_OWNER,TABLE_NAME,COLUMN_NAME,COLUMN_POSITION FROM DBA_IND_COLUMNS WHERE TABLE_NAME='&TABLE_NAME' ORDER BY INDEX_NAME,COLUMN_POSITION;

COL INDEX_NAME FOR A20
COL PARTITION_NAME FOR A15
SELECT INDEX_NAME,INDEX_OWNER,PARTITION_NAME,STATUS,BLEVEL,LAST_ANALYZED FROM DBA_IND_PARTITIONS WHERE INDEX_NAME='&INDEX_NAME' ORDER BY INDEX_NAME;

COL INDEX_NAME FOR A20
COL PARTITION_NAME FOR A15
SELECT INDEX_OWNER,INDEX_NAME,PARTITION_NAME,STATUS,BLEVEL,LAST_ANALYZED FROM DBA_IND_PARTITIONS WHERE INDEX_NAME IN (SELECT INDEX_NAME FROM DBA_INDEXES
WHERE TABLE_NAME='&TABLE_NAME');

SELECT 'ALTER INDEX '||OWNER||'.'||INDEX_NAME||' REBUILD PARALLEL 8 ONLINE;' FROM DBA_INDEXES WHERE TABLE_NAME='&TABLE_NAME' AND STATUS='UNUSABLE';

SELECT 'ALTER INDEX '||INDEX_OWNER||'.'||INDEX_NAME||'REBUILD PARTITION '||PARTITION_NAME||' PARALLEL 8 ONLINE;' FROM DBA_IND_PARTITIONS WHERE STATUS='UNUSABLE';

###############GATHER STATUS

SELECT 'EXEC DBMS_STATS.GATHER_TABLE_STATS(OWNNAME=> '''||OWNER||''',TABNAME=>'''||TABLE_NAME||''',ESTIMATE_PERCENT=> DBMS_STATS.AUTO_SAMPLE_SIZE,
METHOD_OPT=> ''FOR ALL COLUMNS SIZE AUTO '', CASCADE=> TRUE,DEGREE=>16);' FROM DBA_TABLES WHERE 

SELECT 'EXEC DBMS_STATS.GATHER_TABLE_STATS(OWNNAME=> '''||TABLE_OWNER||''',TABNAME=>'''||TABLE_NAME||''',PARTNAME=>'''||PARTITION_NAME||''',
ESTIMATE_PERCENT=>DBMS_STATS.AUTO_SAMPLE_SIZE,METHOD_OPT=>''FOR ALL COLUMNS SIZE AUTO'',CASCADE => TRUE ,DEGREE=> 16);' FROM DBA_TAB_PARTITIONS
WHERE TABLE_OWNER='&TABLE_OWNER' AND TABLE_NAME='&TABLE_NAME';

SELECT 'EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=> '''||USERNAME||''',ESTIMATE_PERCENT=>DBMS_STATS.auto_sample_size,method_opt=>''FOR ALL COLUMNS SIZE AUTO'',
CASCADE=>TRUE,DEGREE=>16);' FROM DBA_USERS WHERE 


################ADD SPLIT PARTITION

# # LIST PARTITION ADD:

ALTER TABLE TABLE_NAME ADD PARTITION PARTITION_NAME VALUES ('VALUE') TABLESPACE TABLESPACE_NAME;

## LIST PARTITION SPLIT:

ALTER TABLE TABLE_NAME SPLIT PARTITION DEFAULT_PARTITION_NAME VALUES ('VALUE') INTO (PARTITION PARTITION_NAME, PARTITION DEFAULT_PARTITION_NAME ) TABLESPACE TABLESPACE_NAME;

## RANGE PARTITION:

ALTER TABLE <TABLE_NAME> ADD PARTITION <NEW_PART_NAME> VALUES LESS THAN (TO_DATE('2016-02-01 00:00:00', 'DD-MON-YYYY HH24:MI:SS'));

ALTER TABLE <TABLE_NAME> SPLIT PARTITION <MAXVALUE_PART_NAME> AT (TIMESTAMP '2016-02-01 00:00:00') INTO (PARTITION <NEW_PART_NAME> TABLESPACE TABLESPACE_NAME,
PARTITION MAXVALUE_PART_NAME) UPDATE GLOBAL INDEX;

################# DROP PRIMARY KEY WITH INDEX AND RECREATE WITH UNIQE PARTITION INDEX

ALTER TABLE GBGM.GDOT_GLBL_PSTN DROP CONSTRAINTS PK_GDOT CASCADE;

CREATE UNIQUE INDEX GBGM.PK_GCIT ON GBGM.GCIT_CFLW_FIX_INCM (PRTN_KEY_ID, ACCT_ID,SUB_ACCT_ID, GLBL_FINL_INSTR_ID, PYBL_YR, PYBL_MTH ) 
TABLESPACE SINAI07_INDEX LOCAL (PARTITION P001 TABLESPACE SINAI07_INDEX);

ALTER TABLE GBGM.GC1T_CFLW_FIX_INCM ADD CONSTRAINT PK_GC1T PRIMARY KEY (PRTN_KEY_ID,ACCT_ID,SUB_ACCT_ID, GLBL_FINL_INSTR_ID, PYBL_YR, PYBL_MTH);

####################ASM COMMANDS:

SELECT NAME, STATE,ROUND(TOTAL_MB/1024,2) TOTAL_GB, ROUND((TOTAL_MB - FREE_MB)/1024,2) USED_GB,ROUND(FREE_MB,1024,2) FREE_GB, ROUND(((TOTAL_MB-FREE_MB)*100/TOTAL_MB),2)
"%USED" FROM v$ASM_DISKGROUP;

COL DISK_GROUP FOR A20
COL DISK FOR A15
COL LABEL FOR A15
COL PATH FOR A40
COL HEADER_STATUS FOR A13
SELECT VDG.NAME DISK_GROUP,vad.name DISK, vad.LABEL,vad.PATH,vad.STATE,vad.HEADER_STATUS,round(vad.TOTAL_MB/1024) SIZE_IN_GB from v$asm_diskgroup vdg,
v$asm_disk vad where vdg.group_number=vad.group_number order by disk_group, disk;


select B.NAME,failgroup,mode_status,count(*) from v$asm_disk A, v$asm_diskgroup B where A.group_number=B.group_number and A.group_number > 0 group by B.NAME,failgroup,mode_status;

#####Copy file from one ASM disk_group to other diskgroup

we should have directory created on source and target with the db link on target to connect to source.

exe dbms_file_transfer.get_file('SOURCE_DIR','SOURCE_FILE','SOURCE_DBLINK','TARGET_DIR','TARGET_FILE');


EXE dbms_file_transfer.get_file('PEGA_BACKUP','prod_ppp_table.dmp','ORAPEGG_link','PEGAQA_BACKUP','prod_ppp_table.dmp');


Standby database / DR / Archive log gap :
=========================================
How to resolve MRP stuck issues on a physical standby database? (Doc ID 1221163.1)

set lines 200 pages 200
col INST for 999
col STARTUP_TIME for a15
col SYSDATE for a15
col DATABASE_ROLE for a10
col open_mode for a15
col host_name for a15
col status for a9
col DB_UNIQUE_NAME for a10
select name db_name,DB_UNIQUE_NAME,OPEN_MODE,DATABASE_ROLE,INST_ID INST,INSTANCE_NAME,HOST_NAME,to_char(STARTUP_TIME,'DD-MON-YY HH24:MI') STARTUP_TIME, 
to_char(SYSDATE,'DD-MON-YY HH24:MI') "SYSDATE" , STATUS, LOGINS from v$database , gv$instance order by inst_id;
col name for a20
col value for a40
SELECT NAME, VALUE FROM V$DATAGUARD_STATS;

--On Physical Standby Server:
select thread#, max(sequence#) "Last Primary Seq Generated" from v$archived_log val, v$database vdb where val.resetlogs_change# = vdb.resetlogs_change# group by thread# order by 1;
--Check received log on standby
select thread#, max(sequence#) "Last Standby Seq Received" from v$archived_log val, v$database vdb where val.resetlogs_change# = vdb.resetlogs_change# group by thread# order by 1;
select thread#, max(sequence#) "Last Standby Seq Applied" from v$archived_log val, v$database vdb where val.resetlogs_change# = vdb.resetlogs_change# and val.applied in ('YES','IN-MEMORY') group by thread# order by 1;

select applied,deleted,decode(rectype,11,'YES','NO') reclaimable,count(*),min(sequence#),max(sequence#) from v$archived_log left outer join sys.x$kccagf using(recid) where is_recovery_dest_file='YES' and name is not null group by applied,deleted,decode(rectype,11,'YES','NO') order by 5;

select THREAD#,SEQUENCE#,applied,deleted from v$archived_log where SEQUENCE# > 1901 order by 1,2;

 
SELECT NAME, VALUE FROM V$DATAGUARD_STATS;
SELECT PROCESS,STATUS, THREAD#,SEQUENCE#, BLOCK#, BLOCKS, INST_ID FROM gV$MANAGED_STANDBY where process like 'MRP%';
SELECT PROCESS,STATUS, THREAD#,SEQUENCE#, BLOCK#, BLOCKS, INST_ID FROM gV$MANAGED_STANDBY ;
select * from v$flash_recovery_area_usage;
DGMGRL STOP MRP :
edit database '<Standby db_unique_name>' set STATE='APPLY-OFF' ;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT FROM SESSION;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT FROM SESSION;
or
RECOVER MANAGED STANDBY DATABASE DISCONNECT;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT PARALLEL 2 NODELAY;
alter database recover managed standby database parallel 4 disconnect;
set line 120 pages 100
col severity for a15
col message for a70
col timestamp for a20
select dest_id,severity,error_code,to_char(timestamp,'DD-MON-YYYY HH24:MI:SS') "timestamp" , message from v$dataguard_status where dest_id=2;
select dest_id,severity,error_code,to_char(timestamp,'DD-MON-YYYY HH24:MI:SS') "timestamp" , message from v$dataguard_status where dest_id=3;

select ds.dest_id id, ad.status, ds.database_mode db_mode, ad.archiver type, ds.recovery_mode, ds.protection_mode, ds.standby_logfile_count "SRLs"
, ds.standby_logfile_active active, ds.archived_seq# from v$archive_dest_status ds, v$archive_dest ad where ds.dest_id = ad.dest_id 
and ad.status != 'INACTIVE' order by ds.dest_id;

SELECT thread#, dest_id, gvad.status, error, fail_sequence FROM gv$archive_dest gvad, gv$instance gvi WHERE gvad.inst_id = gvi.inst_id AND destination is NOT NULL ORDER BY thread#, dest_id;
ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_2=defer sid='*';
ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_2=enable sid='*';


SELECT gvi.thread#, timestamp, message FROM gv$dataguard_status gvds, gv$instance gvi WHERE gvds.inst_id = gvi.inst_id AND 
severity in ('Error','Fatal') ORDER BY timestamp, thread#;

SELECT PROCESS,STATUS, THREAD#,SEQUENCE#, BLOCK#, BLOCKS, INST_ID FROM gV$MANAGED_STANDBY ;
SELECT RECOVERY_MODE FROM GV$ARCHIVE_DEST_STATUS WHERE RECOVERY_MODE!='IDLE';

ALTER SYSTEM SET FAL_SERVER=FINPRD_stby;

To check status of Data Guard synchronization(standby):
SELECT NAME, VALUE FROM V$DATAGUARD_STATS;

To verify there is no log file gap between the primary and the standby database:
SQL> SELECT STATUS, GAP_STATUS FROM V$ARCHIVE_DEST_STATUS WHERE DEST_ID = 3;

To verify that the primary database can be switched to the standby role:

A value of TO STANDBY or SESSIONS ACTIVE indicates that the primary database can be switched to the standby role. If neither of these values is 
returned, a switchover is not possible because redo transport is either misconfigured or is not functioning properly.

SELECT DATABASE_ROLE, DB_UNIQUE_NAME INSTANCE, OPEN_MODE, PROTECTION_MODE, PROTECTION_LEVEL, SWITCHOVER_STATUS FROM V$DATABASE;
select INST_ID,sequence#,archived,applied,DELETED,STATUS from gv$archived_log order by 2; 
select INST_ID,sequence#,archived,applied,DELETED,STATUS from gv$archived_log where sequence# between 17624 and 176479 order by 2; 

To calculate the Redo bytes per second :
SELECT SUM (BLOCKS * BLOCK_SIZE) / 1024 / 1024 / 60 / 60 / 30 REDO_MB_PER_SEC
 FROM GV$ARCHIVED_LOG
 WHERE FIRST_TIME BETWEEN TO_DATE ('01.05.2016', 'DD.MM.YYYY')
 AND TO_DATE ('01.06.2016', 'DD.MM.YYYY')

alter system set log_archive_dest_state_2='defer';
alter system set log_archive_dest_state_2='enable';
alter system archive log current;
alter system switch logfile;

Check if the listener on the standby side and primary side is running as well.
alter system set db_recovery_file_dest_size=1T scope=both;


Recover from service in 19c (Keep the standby database in mount on one node only and other node should be down)
set lines 200 pages 200
col STATUS for a15
col TYPE for a15
col MEMBER for a50
select INST_ID,GROUP#,THREAD#,BYTES,MEMBERS,CON_ID,ARCHIVED,STATUS from gv$log;
select INST_ID,GROUP#,THREAD#,BYTES,CON_ID,ARCHIVED,STATUS from gv$standby_log;
select INST_ID,GROUP#,STATUS,TYPE,MEMBER,CON_ID from gv$logfile;

[oracle@qbepinfdb011 CS0508742]$ cat resync_standby_using_service_v1.sh

rman target / log=/home/oracle/inoapps/IFSLIVEC_${DATE}.log << EOF
RUN {
RECOVER STANDBY DATABASE FROM SERVICE IFSLIVEC;
}
EOF

nohup sh resync_standby_using_service_v1.sh > resync_standby_using_service_v1.out &

Clear the online and standby redolog :
begin
for log_cur in ( select group# group_no from v$log )
loop
execute immediate 'alter database clear logfile group '||log_cur.group_no;
end loop;
end;
/

begin
for log_cur in ( select group# group_no from v$standby_log )
loop
execute immediate 'alter database clear logfile group '||log_cur.group_no;
end loop;
end;
/

Huge Archivelog generation :

Date & Time wise log generation.

set pages 1000
select to_char(COMPLETION_TIME,'DD-MM-YYYY hh24:mm') Hour,thread# , round(sum(BLOCKS*BLOCK_SIZE)/1048576) MB,count(*) Archives 
from v$archived_log where COMPLETION_TIME > sysdate -10
group by to_char(COMPLETION_TIME,'DD-MM-YYYY hh24:mm'),thread# order by 1 ;

Hour wise archive generation:

SELECT to_date(first_time) DAY,
to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)),'999') "00",
to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)),'999') "01",
to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)),'999') "02",
to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)),'999') "03",
to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)),'999') "04",
to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)),'999') "05",
to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)),'999') "06",
to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)),'999') "07",
to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)),'999') "08",
to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)),'999') "09",
to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)),'999') "10",
to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)),'999') "11",
to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)),'999') "12",
to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)),'999') "13",
to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)),'999') "14",
to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)),'999') "15",
to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)),'999') "16",
to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)),'999') "17",
to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)),'999') "18",
to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)),'999') "19",
to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)),'999') "20",
to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)),'999') "21",
to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)),'999') "22",
to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)),'999') "23", count(*) TOT
from
v$log_history
where to_date(first_time) > sysdate -7
GROUP by
to_char(first_time,'YYYY-MON-DD'), to_date(first_time)
order by to_date(first_time)
/

Currently session wise redo generation:
set lines 200 pages 200
col PROGRAM for a16
col MACHINE for a17
col SQL_ID for a7
col USERNAME for a9

select b.inst_id,
       b.SID,b.serial#,
       b.username,
       machine,
	   PROGRAM,
       b.osuser,
       b.status,
       a.redo_mb
from (select n.inst_id, sid,
             round(value/1024/1024) redo_mb
        from gv$statname n, gv$sesstat s
        where n.inst_id=s.inst_id
              and n.name = 'redo size'
              and s.statistic# = n.statistic#
        order by value desc
     ) a,
     gv$session b
where b.inst_id=a.inst_id
  and a.sid = b.sid
and   rownum <= 30
;

%232#DregpsPdf

SELECT INST_ID INST, SID,SERIAL#,USERNAME,STATUS,BLOCKING_SESSION BLOCKER, OSUSER, MACHINE, PROGRAM, SQL_ID,PREV_SQL_ID, TO_CHAR(LOGON_TIME,'DD-MON-YYYY HH24:MI:SS')
LOGON_TIME , LAST_CALL_ET FROM GV$SESSION WHERE SID IN ('304','706','420','16','205','608','21');

Which segments are generating redo logs:

select * from (SELECT to_char(begin_interval_time,'YY-MM-DD HH24') snap_time,dhso.owner,
        dhso.object_name,
        sum(db_block_changes_delta) BLOCK_CHANGED
  FROM dba_hist_seg_stat dhss,
       dba_hist_seg_stat_obj dhso,
       dba_hist_snapshot dhs
  WHERE dhs.snap_id = dhss.snap_id
    AND dhs.instance_number = dhss.instance_number
    AND dhss.obj# = dhso.obj#
    AND dhss.dataobj# = dhso.dataobj#
    AND begin_interval_time BETWEEN to_date('23-03-15 08:00','YY-MM-DD HH24:MI')
                                AND to_date('23-03-20 10:00','YY-MM-DD HH24:MI')
  GROUP BY to_char(begin_interval_time,'YY-MM-DD HH24'),dhso.owner,
           dhso.object_name
  HAVING sum(db_block_changes_delta) > 0
ORDER BY sum(db_block_changes_delta) desc ) where rownum < 10;

############### RMAN / BACKUP  :

select * from v$flash_recovery_area_usage;

############### FLASHBACK  :

https://www.thegeekdiary.com/how-to-create-and-drop-guaranteed-restore-point-in-oracle-data-guard/

set lines 200 pages 200
col name for a20
col time for a40
SELECT NAME, SCN, TIME, DATABASE_INCARNATION#,GUARANTEE_FLASHBACK_DATABASE,CON_ID FROM V$RESTORE_POINT ;
RMAN> list restore point all;

CREATE RESTORE POINT grp_dg GUARANTEE FLASHBACK DATABASE;
CREATE RESTORE POINT IN34268_PDB GUARANTEE FLASHBACK DATABASE;
Drop RESTORE POINT IN33338_PDB;

col name for a60
set lines 200 pages 200
select * from v$flashback_database_logfile;
select * from V$FLASHBACK_DATABASE_LOG;


To check if the local undo is enabled :

col property_name for A20
col property_value for A20
 
select property_name, property_value from database_properties where property_name like '%UNDO%';

PROPERTY_NAME        PROPERTY_VALUE
-------------------- --------------------
LOCAL_UNDO_ENABLED   TRUE

To check if the PDBs have their own UNDO tablespace :

select con_id, tablespace_name from cdb_tablespaces where contents like '%UNDO%' order by 1;
 
    CON_ID TABLESPACE_NAME
---------- --------------------
         1 UNDOTBS1
         3 UNDOTBS1

If Local undo is enabled we can do flashback of PDB.

Steps to create Restore point in dataguard environment :
---------------------------------------------------------
1. Stop redo transport and redo apply

To know that if the broker is configured or not 
show parameter dg_broker_start;
on unix prompt after setting db environment run > dgmgrl
DGMGRL> show configuration;

a) If broker is not configured:

On primary database:
show parameter log_archive_dest_state_2
show parameter log_archive_dest_2

alter system set log_archive_dest_state_2='defer';

On standby database:
alter database recover managed standby database cancel;

If broker is in place:
DGMGRL> edit database chicago set state = 'TRANSPORT-OFF';
DGMGRL> edit database boston set state = 'APPLY-OFF';

2. Set GRP in standby database.
On standby database:
SQL> CREATE RESTORE POINT grp_dg GUARANTEE FLASHBACK DATABASE;

3. Set GRP in primary database
On primary database:
SQL> CREATE RESTORE POINT grp_dg GUARANTEE FLASHBACK DATABASE;

4. Enable redo transport and redo apply.
a) If broker is not configured:

On primary database:
SQL> alter system set log_archive_dest_state_n='enable';
Here, replace n with the corresponding number for remote destinations.

On standby database:
SQL> alter database recover managed standby database using current logfile disconnect;
b) If broker is in place:

DGMGRL> edit database chicago set state = 'TRANSPORT-ON';
DGMGRL> edit database boston set state = 'APPLY-ON';


########### Audit details:

col username for a15
col os_username for a15
col userhost for a25
col terminal for a25
col action_name for a15
select * from (select DU.USERNAME,userhost,terminal,to_char(TIMESTAMP#,'dd-mon-yyyy') TIME, ACTION#,RETURNCODE from AUD$ AU , dba_users DU where
AU.USERID=DU.USER_ID and ACTION#=100 order by TIMESTAMP# desc) where rownum<=&NUM_OF_RECORDS order by rownum desc;

select * from (select username,os_username,userhost,terminal,to_char(timestamp,'dd-mon-yyyy') TIME, ACTION_NAME,RETURNCODE from dba_audit_session 
order by TIMESTAMP desc) where rownum<=&NUM_OF_RECORDS order by rownum desc;

col username for a15
col os_username for a15
col userhost for a25
col terminal for a25
col action_name for a15
select * from (select username,os_username,userhost,terminal,to_char(timestamp,'dd-mon-yyyy') TIME, ACTION_NAME,RETURNCODE from dba_audit_session where
ACTION_NAME='LOGON' order by TIMESTAMP desc) where rownum<=&NUM_OF_RECORDS order by rownum desc;


username='&USERNAME' and 
set lines 200 pages 200
col userid for a15
col os_username for a15
col userhost for a25
col terminal for a25
col ntimestamp# for a30
select * from (select userid,spare1 os_username,userhost,terminal,action#,to_char(NTIMESTAMP#,'DD-MON-YYYY HH24:MI') TIME, RETURNCODE FROM AUD$ WHERE
USERID='&USERID' AND RETURNCODE=1017 ORDER BY ntimestamp# DESC) WHERE ROWNUM<= &NUM_OF_RECORDS ORDER BY ROWNUM DESC;

select * from (select userid,spare1 os_username,userhost,terminal,action#,to_char(NTIMESTAMP#,'DD-MON-YYYY HH24:MI') TIME, RETURNCODE FROM AUD$ WHERE
RETURNCODE=1017 ORDER BY ntimestamp# DESC) WHERE ROWNUM<= &NUM_OF_RECORDS ORDER BY ROWNUM DESC;

alter session set nls_date_format = 'dd-mm-yyyy hh24:mi:ss';
select username, os_username, userhost, client_id,returncode, timestamp from dba_audit_trail where returncode = 1017 and timestamp > sysdate - 50  and  USERNAME LIKE '%&1%'  order by timestamp;

set pagesize 1299
set lines 299
col username for a15
col userhost for a13
col timestamp for a39
col terminal for a23
SELECT username,userhost,terminal,to_char(timestamp,'DD/MM/YY HH24:MI:SS' ) "TIMESTAMP" ,
CASE
when returncode=1017 then 'INVALID-attempt'
when returncode=28000 then 'account locked'
end "FAILED LOGIN ACTION"
FROM dba_audit_session where timestamp > sysdate-1 and returncode in (1017,28000);

ALTER SYSTEM SET RESOURCE_MANAGER_PLAN = 'DEFAULT_CDB_PLAN' SCOPE=BOTH;
Standard Auditing :
--------------------
To check object level auditing :
col owner format a7
col object_name format a7
select * from dba_obj_audit_opts;

To Auditing system privileges :
col user_name format a7
col privilege format a15
select * from dba_priv_audit_opts;

To check statement leavel auditing :
col user_name format a8
col proxy_name format a6
col audit_option format a9
col privilege format a15
select * from dba_stmt_audit_opts;

Unified audit trail :
----------------------
A newly created 12c database might have Unified Auditing disabled: 

SQL> SELECT VALUE FROM V$OPTION WHERE PARAMETER = 'Unified Auditing';

VALUE
----------------------------------------------------------------
FALSE

select  OS_USERNAME,USERHOST,DBUSERNAME,ACTION_NAME,
CASE
when RETURN_CODE=1017 then 'INVALID-attempt'
when RETURN_CODE=28000 then 'account locked'
end "FAILED LOGIN ACTION"
,CLIENT_PROGRAM_NAME,AUTHENTICATION_TYPE from 
unified_audit_trail where RETURN_CODE!='0' and EVENT_TIMESTAMP < sysdate -5/24 order by EVENT_TIMESTAMP desc;

select OS_USERNAME,USERHOST,DBUSERNAME, count(*) from unified_audit_trail 
where EVENT_TIMESTAMP < sysdate -5/24 and RETURN_CODE='1017'  group by OS_USERNAME,USERHOST,DBUSERNAME order by COUNT(*) desc;

select * from (select os_username,username,terminal,to_char(timestamp,'MM-DD-YYYY HH24:MI:SS'),returncode from dba_audit_trail where
returncode > 0 order by timestamp desc) where rownum<30;

audit session whenever not successful;

SELECT username, TIMESTAMP FROM dba_audit_session WHERE username = '&USER_NAME' and ACTION_NAME='LOGON' ORDER BY TIMESTAMP DESC;


create audit policy connection_policy actions logon, logoff;
audit policy connection_policy;
 
 
############# Tablespace / DATAFILE RESIZE:


#################snapshot to old error

#############High undo 

############High Temp Usage

#################### DB Link
set pages 1000 lines 200
col HOST for a35
col USERNAME for a25
col DB_LINK for a30
col OWNER for a20
select OWNER,DB_LINK,USERNAME,HOST,VALID from DBA_DB_LINKS where DB_LINK like '%&LINK_NAME%';

##############Jobs & schedules
Super article on the jobs and schedule and program :

set pages 1000 lines 200
col job_id for 9999
col owner for a15
col last_run for a19
col next_run for a19
col what for a100
select job job_id,schema_user owner,last_date||' '||last_sec LAST_RUN,NEXT_DATE||' '||NEXT_SEC NEXT_RUN ,dj.BROKEN,dj.FAILURES,dj.WHAT 
from dba_jobs dj where JOB like '%&JOB_NAME%';
schema_user='PERFSTAT';
WHAT like '%stat%';
ORAAPPS.ORACLEOUTSOURCING.COM


Query for running Scheduler Jobs:

select s.username, rj.job_name, rj.running_instance, s.sid, s.serial#, p.spid, s.lockwait, s.logon_time
from dba_scheduler_running_jobs rj,
     gv$session s,
     gv$process p
where rj.running_instance = s.inst_id
and   rj.session_id = s.sid
and   s.inst_id = p.inst_id
and   s.paddr = p.addr
–and   p.spid = <spid>
order by s.username, rj.job_name;

Query for seeing broken/failing jobs:

select 'DB1' as DB, Owner, Job_name, Enabled, Run_Count, failure_count Fails, max_failures  Max,  
NVL(TO_CHAR(LAST_START_DATE,'YYYY-MM-DD HH24:MI:SS'),'NULL') Last_start_Date from dba_scheduler_jobs where (max_failures – failure_count) <= 2 order by failure_count desc;

select job job_id,schema_user owner,last_date||' '||last_sec LAST_RUN,NEXT_DATE||' '||NEXT_SEC NEXT_RUN ,BROKEN,FAILURES,WHAT from dba_jobs
where broken='Y' or failures > 0;

select dj.job JOB_ID, drj.sid,dj.schema_user OWNER,dj.LAST_DATE||' '||dj.LAST_SEC LAST_RUN,dj.NEXT_DATE||' '||dj.NEXT_SEC NEXT_RUN,dj.BROKEN,dj.FAILURES,
dj.WHAT from dba_jobs dj,dba_jobs_running drj where dj.job=drj.job;

BEGIN
   DBMS_JOB.REMOVE(job_number);
   COMMIT;
END;
/

BEGIN
   DBMS_JOB.REMOVE(62);
   COMMIT;
END;
/

set lines 200 pages 200
col owner for a10
col JOB_NAME for a25
col PROGRAM_NAME for a25
col JOB_ACTION for a20
select owner,job_name,program_name,job_action,enabled,state,to_char(last_start_Date,'dd-mon-yyyy HH24:MI') LAST_START_DATE,
To_char(NEXT_RUN_DATE,'dd-mon-yyyy HH24:MI') NEXT_RUN_DATE from dba_scheduler_jobs where job_name like 	'%&JOB_NAME%' order by 1;
owner ='PERFSTAT';

set lines 200 pages 200
col owner for a10
col JOB_NAME for a25
col PROGRAM_NAME for a25
col JOB_ACTION for a20
select owner,job_name,program_name,job_action,enabled,state,to_char(last_start_Date,'dd-mon-yyyy HH24:MI') LAST_START_DATE,
To_char(NEXT_RUN_DATE,'dd-mon-yyyy HH24:MI') NEXT_RUN_DATE from dba_scheduler_jobs where job_action like '%&ACTION%' order by 7 desc;

set lines 200 pages 200
col owner for a12
col job_name for a20
col LOG_DATE for a25
col STATUS for a10
col RUN_DURATION for a15
col ERROR# for a8
col ADDITIONAL_INFO for a60
select to_char(LOG_DATE,'dd-mon-yyyy HH24:MI') LOG_DATE_N ,owner,job_name,status,error#,to_char(Actual_start_Date,'dd-mon-yyyy HH24:MI') Actual_start_Date,
run_duration,ADDITIONAL_INFO from ALL_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME like '%&JOB_NAME%' and LOG_DATE > sysdate - 2  order by LOG_DATE ;

select * from (select to_char(LOG_DATE,'dd-mon-yyyy HH24:MI') LOG_DATE_N,owner,job_name,status,error#,to_char(Actual_start_Date,'dd-mon-yyyy HH24:MI')Actual_start_Date,
run_duration,ADDITIONAL_INFO from ALL_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME like '%&JOB_NAME%' order by Actual_start_Date desc) where rownum < 50  ;

select LOG_DATE,owner,job_name,status,error#,Actual_start_Date,run_duration,ADDITIONAL_INFO from ALL_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME like '%&JOB_NAME%' order by Actual_start_Date;
select LOG_DATE,owner,job_name,status,error#,run_duration,ADDITIONAL_INFO from ALL_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME like '%&JOB_NAME%' order by Actual_start_Date;

select LOG_DATE,owner,job_name,status,error#,Actual_start_Date,run_duration,ADDITIONAL_INFO from ALL_SCHEDULER_JOB_RUN_DETAILS 
where JOB_NAME like '%&JOB_NAME%' and status !='SUCCEEDED' order by Actual_start_Date;

select LOG_DATE,owner,job_name,status,error#,Actual_start_Date,run_duration,ADDITIONAL_INFO from ALL_SCHEDULER_JOB_RUN_DETAILS where status !='SUCCEEDED' and LOG_DATE > sysdate - 1  
order by Actual_start_Date;
set lines 200 pages 200
col job_name for a20
col LOG_DATE for a25
col STATUS for a10
col RUN_DURATION for a15
col ERROR# for a8
col ADDITIONAL_INFO for a20
col JOB_ACTION for a20
col PROGRAM_NAME for a20
select OWNER,JOB_NAME,PROGRAM_NAME,JOB_TYPE,JOB_ACTION,SCHEDULE_TYPE,RESTART_ON_FAILURE, ENABLED,STATE,SYSTEM ,to_char(START_DATE,'dd-mon-yyyy HH24:MI') START_DATE 
from DBA_SCHEDULER_JOBS where JOB_NAME like '%&JOB_NAME%';
select OWNER,JOB_NAME,PROGRAM_NAME,JOB_TYPE,JOB_ACTION,SCHEDULE_TYPE, ENABLED,STATE,SYSTEM ,to_char(START_DATE,'dd-mon-yyyy HH24:MI') START_DATE 
from DBA_SCHEDULER_JOBS where JOB_NAME like '%&JOB_NAME%';

set lines 200 pages 200
col owner for a12
col job_name for a35
col status for a12
select to_char(LOG_DATE,'dd-mon-yyyy HH24:MI') LOG_DATE,owner,job_name,status,ADDITIONAL_INFO from DBA_SCHEDULER_JOB_LOG where JOB_NAME like '%&JOB_NAME%' and LOG_DATE > sysdate - 1 order by 1 desc;


col window_name for a20
col resource_plan for a30
col LAST_START_DATE for a37
col DURATION for a20
select window_name,resource_plan,LAST_START_DATE,DURATION,ENABLED from DBA_SCHEDULER_WINDOWS;

select CLIENT_NAME,OPERATION_NAME,STATUS from dba_autotask_operations;

col CLIENT_NAME for a30
col WINDOW_NAME for a20
col WINDOW_START_TIME for a40
col WINDOW_DURATION for a10
select * from DBA_AUTOTASK_CLIENT_HISTORY;
select * from DBA_AUTOTASK_CLIENT_JOB;
select client_name,status from DBA_AUTOTASK_CLIENT;
DBA_AUTOTASK_CLIENT_JOB
Contains information about currently running Scheduler jobs created for automated maintenance tasks. It provides information about some objects targeted by those jobs, as well as some additional statistics from previous instantiations of the same task. Some of this additional data is taken from generic Scheduler views.

DBA_AUTOTASK_CLIENT
Provides statistical data for each automated maintenance task over 7-day and 30-day periods.

DBA_AUTOTASK_JOB_HISTORY
Lists the history of automated maintenance task job runs. Jobs are added to this view after they finish executing.

DBA_AUTOTASK_WINDOW_CLIENTS
Lists the windows that belong to MAINTENANCE_WINDOW_GROUP, along with the Enabled or Disabled status for the window for each maintenance task. Primarily used by Cloud Control.

DBA_AUTOTASK_CLIENT_HISTORY
Provides per-window history of job execution counts for each automated maintenance task. This information is viewable in the Job History page of Cloud Control.


set pagesize 1000
set linesize 150
column REQ_START_DATE format a37
column ACTUAL_START_DATE format a37
column log_date format a37
column window_name format a10
column operation format a9
column error# format 99999
column status format a9
column CPU_USED format a16
column job_name format a18
column run_duration format a15
select log_date, owner, job_name, operation, status  from dba_scheduler_job_log 
union
select log_date, 'SYS', window_name, operation, status from dba_scheduler_window_log  
order by 1;

Check the job timing with following commands
--------------------------------------------
select operation,target,start_time,end_time from dba_optstat_operations where operation='gather_database_stats(auto)';

exec dbms_auto_task_admin.disable(client_name=> 'auto optimizer stats collection');
exec dbms_auto_task_admin.enable(client_name=>'auto optimizer stats collection');

col window_name for a21
col start_time for a40
col DURATION for a20
select * from dba_autotask_schedule order by start_time;

col client_name for a32
col job_name for a25
col JOB_START_TIME for a16
col JOB_STATUS for a25
select client_name,job_name,job_status,to_char(JOB_START_TIME,'DD-MON-YYYY HH24:MI') JOB_START_TIME,JOB_DURATION from DBA_AUTOTASK_JOB_HISTORY 
where job_start_time > systimestamp -1 order by job_start_time,client_name;

col owner for a15
col name for a25
col Text for a90
select OWNER,NAME,LINE,TEXT from dba_errors where name='&NAME';

select client_name, status, consumer_group, window_group FROM dba_autotask_client where client_name = 'sql tuning advisor';
select status, execution_end from dba_advisor_executions where task_name='SYS_AUTO_SQL_TUNING_TASK' order by 2 desc;
select parameter_name, parameter_value from dba_advisor_parameters where task_name='SYS_AUTO_SQL_TUNING_TASK' order by 1;
select DBMS_Auto_SQLTune.Report_Auto_Tuning_Task from dual;


How to create the jobs and how to check that .
https://support.dbagenesis.com/post/scheduling-jobs-with-dbms_scheduler

set lines 999;
col owner for a20;
col program_name for a30;
SELECT owner, program_name, enabled FROM dba_scheduler_programs where program_name like '&enter_program_name';
set lines 999;
col schedule_name for a30;
SELECT owner, schedule_name from DBA_SCHEDULER_SCHEDULES;
set lines 999;
col job_name for a30;
select owner, job_name, enabled from dba_scheduler_jobs;

BEGIN
  DBMS_SCHEDULER.run_job (job_name => 'test_sched_job', use_current_session => TRUE);
END;
/
To drop a job

BEGIN
  DBMS_SCHEDULER.drop_job (job_name=>'test_sched_job');
END;
/
-- to disable a job
BEGIN
  DBMS_SCHEDULER.disable (name=>'test_sched_job');
END;
/

-- to enable a job
BEGIN
  DBMS_SCHEDULER.enable (name=>'test_sched_job');
END;
/


#################### MVIES
set lines 200 pages 200
col owner for a15
col object_name for a30
col created for a18
col LAST_DDL_TIME for a18
select owner,object_name,object_type,status,to_char(CREATED,'DD-MON-YYYY') CREATED,to_char(LAST_DDL_TIME,'DD-MON-YYYY HH24:MI') LAST_DDL_TIME
from dba_objects where OBJECT_TYPE='MATERIALIZED VIEW' and Object_name='&OBJECT_NAME' order by owner;

col LAST_REFRESH_DATE for a18
col STALE_SINCE for a18
select owner,MVIEW_NAME,REWRITE_ENABLED,REFRESH_MODE,REFRESH_METHOD,FAST_REFRESHABLE,LAST_REFRESH_TYPE,to_char(LAST_REFRESH_DATE,'DD-MON-YYYY HH24:MI')
LAST_REFRESH_DATE,STALENESS,COMPILE_STATE,to_char(stale_since,'dd-mon-yyyy hh24:mi') STALE_SINCE from dba_mviews where mview_name='&mview_name';


SELECT * FROM ( SELECT OWNER, MVIEW_NAME, CONTAINER_NAME, REFRESH_MODE, REFRESH_METHOD, LAST_REFRESH_TYPE,STALENESS,
ROUND((LAST_REFRESH_END_TIME-LAST_REFRESH_DATE)*24*60,2) as REFRESH_TIME_MINS FROM ALL_MVIEWS WHERE LAST_REFRESH_TYPE IN ('FAST','COMPLETE')) 
ORDER BY REFRESH_TIME_MINS DESC;

https://dbatracker.com/2020/08/07/post-import-mview-troubleshooting/

set lines 300
set pages 300
 col owner for a10
col MVIEW_NAME for a30
select owner,MVIEW_NAME,STALENESS,COMPILE_STATE,UNKNOWN_IMPORT,REFRESH_MODE, REFRESH_METHOD,LAST_REFRESH_DATE from dba_mviews where MVIEW_NAME='&MVIEW_NAME' order by owner,MVIEW_NAME;

Compile Mview :
select 'alter MATERIALIZED VIEW '||owner||'.'||MVIEW_NAME||' compile;' from dba_mviews ;
MView refresh Complete 
select 'execute dbms_mview.refresh('||''''||owner||'.'||MVIEW_NAME||''''||','||''''||'C'||''''||');' from dba_mviews where MVIEW_NAME='&MVIEW_NAME';
MView refresh Fast 
select 'execute dbms_mview.refresh('||''''||owner||'.'||MVIEW_NAME||''''||','||''''||'F'||''''||');' from dba_mviews ;


Mview schedular job status check :
set lines 300
set pages 1000
col JOB_NAME for a30
col OWNER for a10
col ADDITIONAL_INFO for a40
col LOG_DATE for a40
select OWNER,JOB_NAME,LOG_DATE,STATUS,ADDITIONAL_INFO,RUN_DURATION from DBA_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME='QBE_HIERARCHY_MV' order by LOG_DATE;

Mview details :
SET LONG 9999999 LONGCHUNKSIZE 20000 PAGESIZE 0 LINESIZE 1000 FEEDBACK OFF VERIFY OFF TRIMSPOOL ON
select dbms_metadata.get_ddl('MATERIALIZED_VIEW','&MATERIALIZED_VIEW','&OWNER') from dual;

Checking the child mview :
set lines 300
select  name, owner, master_owner, master from dba_snapshots where master ='&MASTER_MVIEW';

########### Parameter / Parameter file / SPfile / Pfile
col parameter for a25
col value for a30
select INST_ID INST, NAME, PARAMETER, ROUND(VALUE/1024/1024/1024,2) SIZE_IN_GB FROM GV$PARAMETER WHERE NAME IN ('SGA_TARGET','','','')

set lines 200 pages 200
col DB_UNIQ_NAME for a20
col SID for a5
col NAME for a15
col VALUE$ for a15
col COMMENT$ for a20
col SPARE3 for a20
select * from pdb_spfile$ where NAME='shared_pool_size';
 

Parameter which can be changed at PDB level :
set lines 200 pages 200
col NAME for a20
col VALUE for a25
col ISINSTANCE_MODIFIABLE for a20
select INST_ID,CON_ID,name,ISDEFAULT,VALUE,ISSES_MODIFIABLE ,ISSYS_MODIFIABLE,ISPDB_MODIFIABLE ,ISINSTANCE_MODIFIABLE  
from gv$parameter where lower(name) like '%&parameter%' ;
%
PDB level values are stored in root container table and we can also check using below query :
set lines 200 pages 200
col PDB_NAME for a10
col NAME for a40
col VALUE$ for a40
select  pdb.dbid, pdb.CON_ID, pdb.NAME PDB_NAME,sp.NAME, sp.value$ from v$pdbs pdb, pdb_spfile$ sp where pdb.name = 'IFSDEV' 
and pdb.con_uid=sp.pdb_uid order by sp.name;


Hidden Parameter Value :

set lines 132
column ksppinm format a50
column ksppstvl format a30
 
select a.ksppinm, b.ksppstvl
from x$ksppi a,x$ksppsv b
where a.indx=b.indx
and substr(a.ksppinm,1,1) = '_'
and lower(a.ksppinm) like '%&hidden_parameter%'
order by ksppinm;

***********
WRITE QUERY MORE QUERY CHECK SCREEN SHOT 
*********


############ COMPONENT USAGE 

SELECT NAME,VERSION,DETECTED_USAGES,CURRENTLY_USED,FIRST_USAGE_DATE,LAST_USAGE_DATE,LAST_SAMPLE_DATE FROM DBA_FEATURE_USAGE_STATISTICS WHERE CURRENTLY_USED='TRUE';

############ FLUSH SQL PLAN FROM SHARED POOL

select address,hash_value from v$sql_area where sql_id='&sql_id';

EXEC DBMS_SHARED_POOL.PURGE ('&ADDRESS,&HASH_VALUE','C');

####################################### Gather Stat:
select client_name,status from dba_autotask_client;
select client_name, JOB_SCHEDULER_STATUS  from DBA_AUTOTASK_CLIENT_JOB where client_name='auto optimizer stats collection';

set lines 200 pages 200
col WINDOW_NAME for a15
col JOB_NAME for a20
col JOB_STATUS for a15
col JOB_DURATION for a20
col JOB_START_TIME for a20
SELECT window_name,job_name, job_status, job_duration,JOB_START_TIME FROM DBA_AUTOTASK_JOB_HISTORY WHERE client_name='auto optimizer stats collection' AND window_start_time >= SYSDATE -5 ORDER BY job_start_time DESC;
exec DBMS_AUTO_TASK_ADMIN.ENABLE( client_name => 'auto optimizer stats collection',  operation => NULL,  window_name => NULL);
exec DBMS_AUTO_TASK_ADMIN.DISABLE( client_name => 'auto optimizer stats collection', 
 operation => NULL, 
 window_name => NULL);






################################# TNS entry for PDB :
PQBEII =

(DESCRIPTION =                                                             

   (ADDRESS = (PROTOCOL = TCP) (HOST = qbepebsdb01-scan.qbeproddb.vcnqbeprd.oraclevcn.com)(PORT = 3010))

   (CONNECT_DATA =

     (SERVER = DEDICATED)

     (SERVICE_NAME = pqbeii)

   )

)


ACL : 
======
https://oracleagent.wordpress.com/2021/02/13/acl_oracle/
Displays information about host ACLs:
COLUMN acl FORMAT A50
COLUMN host FORMAT A20
COLUMN acl_owner FORMAT A10
SELECT HOST, LOWER_PORT, UPPER_PORT, ACL, ACLID, ACL_OWNER FROM dba_host_acls ORDER BY host;

Displays information about host ACEs :
COLUMN host FORMAT A20
COLUMN principal FORMAT A30
COLUMN privilege FORMAT A30
COLUMN start_date FORMAT A11
COLUMN end_date FORMAT A11

SELECT host, lower_port, upper_port, ace_order, TO_CHAR(start_date, 'DD-MON-YYYY') AS start_date, TO_CHAR(end_date, 'DD-MON-YYYY') AS end_date, grant_type, inverted_principal, principal, principal_type, privilege FROM dba_host_aces ORDER BY host, ace_order;

set lines 200 pages 200
COLUMN acl FORMAT A30
COLUMN principal FORMAT A30
SELECT acl,principal,privilege,is_grant,TO_CHAR(start_date, 'DD-MON-YYYY') AS start_date,TO_CHAR(end_date, 'DD-MON-YYYY') AS end_date
FROM dba_network_acl_privileges;

################################# Unix Linux commands
screen -S Patching_precheck => To create screen 
screen -ls => To list screen
screen -r <Screen name> to attach to screen
screen -rD <Screen name> to reattach to screen when someone is already attached
ctrl+A+D => To detach from the screen 
exit => To exit from screen

shutdown -rf now

Cron job details : 
#0-59 0-23 1-31 1-12 0-6
#Min Hr Date Mth Day Command

PS1="STEPDEV> "[\u@\h \W]\$
PS1="STEPDEV>" [\W]\$
PS1="STEPTEST> "
PS1="STEPPROD> "

History command in linux 
export HISTTIMEFORMAT="%F %T "

export HISTTIMEFORMAT="%d/%m/%y %T "
history

find . -name "DigiCert*" -type f 
find . -name "step-datapump-export.pl*" -type f 

listener port details:
lsof -i tcp:1521 | grep Listen

netstat -an| grep LISTEN

ps -ef | egrep 'pmon|tns'|grep -v grep | grep -i 

purgeLogs: Archive & Cleanup traces, logs in one command (Doc ID 2081655.1)

find . -name "*.trc" -type f -mtime +10 -delete 
find . -name "*.trm" -type f -mtime +10 -delete 
find . -name "log_*.xml" -type f -mtime +7 -delete 
find . -name "*.aud" -type f -mtime +20 -delete 
find . -name "alert_PQBEIIc1*" -type f -mtime +30 -delete 
find . -name "cdmp_*" -mtime +15 -exec rm {} \;
find . -name "*.aud" -type f -mtime +30 -delete 

find . -name "*.aud" -type f -mtime +90 -delete 
find . -name "*.aud.gz" -type f -mtime +60 -delete 

find . -name "IFSLIVEC3_*.trc.gz" -type f -mtime +2 -delete 
find . -name "IFSLIVEC3_*.trm.gz" -type f -mtime +2 -delete 
find . -name "+ASM2_*.trm" -type f -mtime +7 -delete 

find . -name ".trc" -mtime +15 -exec mv {} \;

To display the largest folders/files including the sub-directories
du -Sh | sort -rh | head -5

If you want to display the biggest file sizes only, then run the following command:
find /home/tecmint/Downloads/ -type f -exec du -Sh {} + | sort -rh | head -n 5
find . -type f -exec du -Sh {} + | sort -rh | head -n 10

delete directory :
find . -type d -ctime +100 | xargs rm -rf
find . -type d -name "incdir_*" -ctime +15 | xargs rm -rf

find /u01/app/oracle/admin/*/adump -type f -name '*.aud' -mtime +7 -delete


adrci> purge -age 600 -type ALERT
adrci> purge -age 600 -type TRACE
adrci> purge -age 10080 -type incident
adrci> purge -age 10080 -type cdump

find / -iname archive_to_dr.ksh


Deleting in windows server : 
rem ### REPORT

cd /d D:\product\diag\rdbms\report\report1\trace	
rename D:\product\diag\rdbms\report\report1\trace\alert_report1.log alert_report1_%THEDATE%.log
forfiles -p D:\product\diag\rdbms\report\report1\trace\ -m *.trc -d -31 -c "CMD /c del /Q @FILE"
forfiles -p D:\product\diag\rdbms\report\report1\trace\ -m *.trm -d -31 -c "CMD /c del /Q @FILE"
forfiles -p D:\product\diag\rdbms\report\report1\trace\ -m cdmp* -d -31 -c "CMD /c rmdir /S /Q @FILE"

rem ### LISTENER
cd /d D:\product\11.1.0\asm_1\log\diag\tnslsnr\UKLONOR01\listener_uklonor01\trace
rename D:\product\11.1.0\asm_1\log\diag\tnslsnr\UKLONOR01\listener_uklonor01\trace\listener_uklonor01.log listener_uklonor01_%THEDATE%.log
forfiles -p D:\product\11.1.0\asm_1\log\diag\tnslsnr\UKLONOR01\listener_uklonor01\trace\ -m *.log -d -31 -c "CMD /c del /Q @FILE"

cd /d D:\product\11.1.0\asm_1\log\diag\tnslsnr\UKLONOR01\listener_uklonor01\alert
forfiles -p D:\product\11.1.0\asm_1\log\diag\tnslsnr\UKLONOR01\listener_uklonor01\alert\ -m *.xml -d -31 -c "CMD /c del /Q @FILE"

rem ### ASM

cd /d D:\product\11.1.0\asm_1\database\diag\asm\+asm\+asm1\trace
rename "D:\product\11.1.0\asm_1\database\diag\asm\+asm\+asm1\trace\alert_+asm1.log" "alert_+asm1_%THEDATE%.log"

forfiles -p D:\product\11.1.0\asm_1\database\diag\asm\+asm\+asm1\trace\ -m *.trc -d -32 -c "CMD /c del /Q @FILE"
forfiles -p D:\product\11.1.0\asm_1\database\diag\asm\+asm\+asm1\trace\ -m *.trm -d -32 -c "CMD /c del /Q @FILE"
forfiles -p D:\product\11.1.0\asm_1\database\diag\asm\+asm\+asm1\trace\ -m cdmp* -d -32 -c "CMD /c rmdir /S /Q @FILE"


FAILURE: PGLTYI  on gtp1db1.int.gt.com - archive_to_dr.ksh	

Sar command :
https://www.thegeekstuff.com/2011/03/sar-examples/
https://www.thegeekdiary.com/how-to-view-past-performance-with-sar-in-linux/
To check for the I/O details :
sar -p -d -b 1
SAR reort location in oracle cloud.
sar -u -s 00:00:00 -e 23:00:00
sar -u -s 14:00:00 -e 14:30:00 -f /var/log/sysstat/sa19
sar -r -s 10:00:00 -e 12:00:00 -f /var/log/sa/sa24
sar -P ALL -s 00:00:00 -e 23:50:00 -f /var/log/sa/sa20
sar -P ALL -s 00:00:00 -e 23:50:00 -f /var/log/sa/sa30
sar -P ALL -s 00:00:00 -e 23:50:00 -f /var/log/sa/sa31
sar -q -s 00:00:00 -e 23:00:00 -f /var/log/sa/sa2
sar -u -s 00:00:00 -e 23:59:00 -f /var/log/sa/sa08
sar -S -s 00:00:00 -e 23:59:00 -f /var/log/sa/sa12
sar -u -s 00:00:00 -e 23:00:00 -f /var/log/sa/sa15
-r memory usage 
-P CPU usage 
-S Swap space usage 
-b reports I/O statistics
tps – Transactions per second (this includes both read and write)
rtps – Read transactions per second
wtps – Write transactions per second
bread/s – Bytes read per second
bwrtn/s – Bytes written per second
 17, 2023 3:47 AM
-q Reports run queue and load average (sar -q) This reports the run queue size and load average of last 1 minute, 
    5 minutes, and 15 minutes. “1 3” reports for every 1 seconds a total of 3 times
    The “blocked” column displays the number of tasks that are currently blocked and waiting for I/O operation to complete.
iostat output	 :
sar -d -f 14:00:00 -e 16:00:00 -f /var/log/sa/sa07
oswatcher / OS WATCHER : 

java -jar oswbba.jar -i /u02/home/osw/archive
java -jar oswbba.jar -i /u01/app/oracle.ahf/data/repository/suptools/edi-dataserv-prddb/oswbb/grid/archive

If you want to compress the file and keep the original file you have to run the gzip command with -k option:
 $ gzip -k mydoc.txt
 gzip -c filename.extension > filename.extension.gz
 gzip < filename.extension > myfile.extension.gz
 
To decompress .gz files, use:

gzip -d filename.gz

One can unzip and open gz file using:
gunzip archive.gz

For .tar.gz/.tgz file try the tar command:
tar -xvf archive.tar.gz
tar -xzf bar.tar.gz -C foo

nohup tar -zcvf /oracle/backup/clone_${THEDATE}/EBSapps_fs2.tar.gz $RUN_BASE/EBSapps/ &
nohup tar zxvf /oracle/backup/EBSapps_fs1.tar.gz -C /apps/train_122/fs1/ --strip-components 3 &

tar -zcvf /tmp/archive.tar.gz archive 
tar -zcvf root.tar.gz root 

Listener failed attempt check :

grep "28-MAY" /opt/oracle/diag/tnslsnr/stagedevdb2/listener/trace/listener.log | awk  '{ if ( $NF != 0 ) print $0 }'

grep "28-MAY" listener.log | awk  '{ if ( $NF != 0 ) print $0 }'

how to check OSwatcher is running ?

ps -elf | grep OSWatcher  | grep -v grep
Package :
---------
To check for the package :
[root@oraexa01db01 ~]# yum list | grep -i cups
Give details with last install dates: 
[root@oraexa01db01 ~]# rpm -qa --last | grep -i cups
cups-filters-libs-1.0.35-28.0.1.el7.x86_64    Thu 11 Nov 2021 10:20:05 AM GMT
cups-client-1.6.3-51.el7.x86_64               Thu 11 Nov 2021 10:20:05 AM GMT
cups-libs-1.6.3-51.el7.x86_64                 Tue 12 Oct 2021 01:12:38 AM BST

rpm -qf /usr/sbin/postfix
rpm -ql postfix-3.5.8-7.el8.x86_64

[root@oraexa01db01 ~]# rpm -qa | grep -i cup
cups-client-1.6.3-51.el7.x86_64
cups-filters-libs-1.0.35-28.0.1.el7.x86_64
cups-libs-1.6.3-51.el7.x86_64
List the directory where it has installed the files :
[root@oraexa01db01 ~]# rpm -ql cups-client-1.6.3-51.el7.x86_64
/usr/bin/cancel.cups
/usr/bin/lp.cups
/usr/bin/lpoptions
/usr/bin/lppasswd
/usr/bin/lpq.cups
/usr/bin/lpr.cups
/usr/bin/lprm.cups
/usr/bin/lpstat.cups
/usr/sbin/lpc.cups
/usr/share/man/man1/cancel-cups.1.gz
/usr/share/man/man1/lp-cups.1.gz
/usr/share/man/man1/lpoptions.1.gz
/usr/share/man/man1/lppasswd.1.gz
/usr/share/man/man1/lpq-cups.1.gz
/usr/share/man/man1/lpr-cups.1.gz
/usr/share/man/man1/lprm-cups.1.gz
/usr/share/man/man1/lpstat-cups.1.gz
/usr/share/man/man8/lpc-cups.8.gz

Details of the package :
[root@oraexa01db01 ~]# rpm -qi cups-client-1.6.3-51.el7.x86_64
Name        : cups-client
Epoch       : 1
Version     : 1.6.3
Release     : 51.el7
Architecture: x86_64
Install Date: Thu 11 Nov 2021 10:20:05 AM GMT
Group       : System Environment/Daemons
Size        : 170476
License     : GPLv2
Signature   : RSA/SHA256, Sun 24 May 2020 11:55:20 PM BST, Key ID 72f97b74ec551f
Source RPM  : cups-1.6.3-51.el7.src.rpm
Build Date  : Sun 24 May 2020 11:54:12 PM BST
Build Host  : jenkins-10-147-72-125-aa155b83-e512-4702-8edf-7d9fcf0ca406.appad3i
Relocations : (not relocatable)
Vendor      : Oracle America
URL         : http://www.cups.org/
Summary     : CUPS printing system - client programs
Description :
CUPS printing system provides a portable printing layer for
UNIX® operating systems. This package contains command-line client
programs.

To check the package update date after OS patching :
rpm  -qa -last

To know the distribution of OS 
[root@oraexa01db01 ~]# cat /etc/os-release


ADRCI :
Show alert    => Show the current alert log
Show alert -tail 100 => show last 100 linese
Show alert -tail -f => 
Show alert -p "MESSAGE_TEXT like '%ORA-%'"  => show error in alert log 
Show alert -p " MESSAGE_TEXT like '%ORA-%' and originating_timestamp > systimestamp - 1"   => Same as above but restrict to 1 day previous

adrci> show homes
adrci> set home diag/tnslsnr/oradb1/listener
adrci> purge -age 10800 -type TRACE                   => its in minute
adrci> purge -age 43200 -type TRACE
adrci> purge -age 10800 -type ALERT
adrci> purge -age 3600 -type ALERT
purge -age 43200 -type ALERT
adrci> show control
adrci> set control (SHORTP_POLICY = 168)
adrci> set control (LONGP_POLICY = 168)
adrci> show control
ls -ld cdmp_202306{28..30}*
rm -fr cdmp_202306{28..30}*

CPU utilization command:
top              ==> By default the command top will show you an aggregation of the cpu usage. After running top you can hit the 1 key and 
					 it will show you all of the cpus individually
mpstat –P ALL
iostat -c 2 2    ==> The reason for this is that on a single run of iostat the statistics reported are since system boot. iostat -c 2 2 will report once since boot, then 2 seconds later with a second report since the previous.
vmstat -t 1 5    ==> Display with timestamp
vmstat -S M 1 5  ==> Display in megabyte
iostat -d        ==> iostat with -d arguments display only disk I/O statistics of all partitions 
iostat -N        ==> With -N (Uppercase) parameter displays only LVM statistics as shown.

Kill user process id :
kill -9 `ps -ef | grep $USER | grep /pqbei3 | grep -v grep | awk '{print $2}'`

Killing multiple process :
ps -ef|grep -i LOCAL=NO |awk '{print $2}'|xargs kill -9


Top 10 CPU usage process 
ps -eo pcpu,pid,user,args | sort -k 1 -r | head -10

du -hs * | sort -rh | head -5

To display the largest folders/files including the sub-directories
du -Sh | sort -rh | head -5

If you want to display the biggest file sizes only, then run the following command:
find /home/tecmint/Downloads/ -type f -exec du -Sh {} + | sort -rh | head -n 5

kill process multiple :
ps -ef|grep ggate|grep 'grep monitoring'| awk '{print $2}'|xargs -t -i echo kill -9 {}
ps aux | grep 'monitoring ' | awk '{print $2}'

Inodes Details : Oracle Linux: How to Identify Folders Using High Inodes (Doc ID 2705358.1)
===============  OL6 : Inodes Are Full or 100% For But Space Usage Is Not Full (Doc ID 2342233.1)
=================================================================================================
To check the inode usage of a file system, run the below command.
#df -i

Filesystem                      Inodes            IUsed       IFree     IUse%        Mounted on
/dev/mapper/vg00-root            47185920          389073     46796847   1%            /
/dev/sda2                        1048576           99         1048477    1%            /boot
/dev/sda1                        0                 0          0          -             /boot/efi

a) ACFS filesystems does not use the inode architecture.
b) ACFS filesystems does not have a pre-allocated inode table.
1) Therefore, "df -i" command returns the number of inodes that are theoretically possible given the space remaining.
2) On ACFS filesystems, the inode table grows dynamically. Any free storage is eligible for inode creation.
3) Thus, "df -m" command (with the "-m" option or equivalent) needs to be used instead to report the real ACFS filesystem allocation and available free space, as follows:

[root@dbaasm ~]# df -m /u04acfs
Filesystem              1M-blocks       Used       Available Use% Mounted on
/dev/asm/ebernal-225     20971520       209715     20761805    1% /u04acfs

To find out the inode usage under /var run below commands.
#cd /var
#echo "Detailed Inode usage for: $(pwd)" ; for d in `find -maxdepth 1 -type d |cut -d\/ -f2 |grep -xv .`; do c=$(find $d |wc -l) ; printf "$c\t\t- $d\n"; done | sort -rn; printf "$(find $(pwd) | wc -l)"


AIX commands :
===============

df -k 
topas
du -sm


To add service in PDB :

srvctl add service -db cpdb -service hr1 -pdb pdb1 -preferred cpdb1 -available cpdb2
SELECT NAME, PDB FROM all_services;

srvctl stop database -d DB_NAME -o immediate
srvctl stop database -d DB_NAME -o abort
srvctl stop instance -d <db uniq name> -i RAM1
srvctl stop asm -n NODE_NAME -o immediate
srvctl start asm -n NODE_NAME 
srvctl status asm -n NODE_NAME 
srvctl config asm -n NODE_NAME 

srvctl status service -d db_name
srvctl config service -d db_name
srvctl start service -d dbname -s service_name
srvctl stop service -d dbname -s service_name
srvctl add service -d {DB_NAME} -s {SERVICE_NAME} -r {"preferred_list"} -a {"available_list"} [-P {BASIC | NONE | PRECONNECT}]
srvctl relocate service -d db_name -s service_name -i instance_name -t new_instance_name [-f]

srvctl status nodeapps -n nodename
srvctl config nodeapps -n nodename


srvctl start instance -d OLAP -i OLAP2
srvctl status asm -n UKLONOR02
crsctl stat res -t
Crsctl 
crs_stat -t
crs_start -f ora.uklonor02.ASM2.asm
crs_stop ora.uklonor02.ASM2.asm

Script :
=========
-bash-4.2$ cat gatherstat.sh
export TNS_ADMIN=/dqbe43/3rdparty/oracle/product/12102/network/admin/adw
sqlplus admin/NW5_NVeKlLy2TL4_Ejzu@dqbe43adw_low <<EOF
@/pqbei3/oraclebi12c/inoapps/gatherstats/gatherstats.sql;
EOF
chmod 777 gatherstats.sql gatherstats.sh
sh gatherstat.sh

-bash-4.2$ cat alter_tab.sh
export TNS_ADMIN=/dqbe43/3rdparty/oracle/product/12102/network/admin/adw
sqlplus admin/NW5_NVeKlLy2TL4_Ejzu@dqbe43adw_low <<EOF
@/dqbe43/oraclebi12c/inoapps/scripts/alt_wc_journal_attributes_d.sql
EOF

00 22 18 10 * /dqbe43/oraclebi12c/inoapps/scripts/alt_wc_journal_att_d.sh > /dev/null 2>&1

chmod 777 gatherstats.sql gatherstats.sh
sh gatherstat.sh



Daily check script: 
-------------------
SetEnvironment()
{
export ORACLE_BASE=/u01/app/oracle
#export ORACLE_HOME=$ORACLE_BASE/product/18.0.0.0/dbhome_1
export ORACLE_HOME=$ORACLE_BASE/product/19.0.0.0/dbhome_3
export ORACLE_SID=SAS1
export TS=`date +"%d%b%Y_%T"`
export OUTPUT=/home/oracle/dba/logs/DailyChecksSAS.htm
export SQL_DIR=/home/oracle/dba/jobs/sql
rm -rf  $OUTPUT || true
}

RunDailyCheck()
{
$ORACLE_HOME/bin/sqlplus  -S " / as sysdba"  <<EOF | tee -a ${OUTPUT}
@${SQL_DIR}/DailyChecks.sql;
EOF
}

SendMail()
{
cat <<'EOF' - ${OUTPUT}  | /usr/sbin/sendmail -t
To: waseem.shahzad@frasers.group, david.henderson@frasers.group, mohammad.niazi@frasers.group, stephen.hazlehurst@frasers.group, john.ashley@frasers.group
#To:  mohammad.niazi@frasers.group
#TO: stephen.hazlehurst@frasers.group
Subject:SAS Live - Production Daily Checks
Content-Type: text/html

EOF
}

        SetEnvironment
        RunDailyCheck
        SendMail


################################################################################################################################### 
Exadata commands :
==================
Command list :
https://satya-dba.blogspot.com/2018/07/cellcli-commands-in-oracle-exadata.htmlhttps://satya-dba.blogspot.com/2018/07/cellcli-commands-in-oracle-exadata.html

xm list => This is the command to check how many VM is running on exadata / It will also report if VM is running or down
if we need to shutdown vm running on Dom0 then use shutdown -h now

Description details will be availabel in https://docs.oracle.com/en/engineered-systems/exadata-database-machine/sagug/exadata-storage-server-cellcli.html#GUID-99115475-820B-4C6F-AE9F-98B6DBF47C05

dbmcli > LIST ALERTHISTORY WHERE ageInMinutes < 15

dbmcli > LIST ALERTHISTORY WHERE alertShortName = 'Hardware' 
dbmcli > LIST ALERTHISTORY WHERE severity= 'critical'
dbmcli > LIST ALERTHISTORY 1871_9 DETAIL
dbmcli > LIST ALERTHISTORY  WHERE severity= 'info' and ageInMinutes < 15 
dbmcli > list alerthistory where notificationState like '[023]' and severity like '[warning|critical]' and examinedBy = NULL;
dbmcli > list alerthistory where alertType = Stateless
dbmcli > list alerthistory where alertType = Stateful
dbmcli > LIST object_type  [ name |  attribute_filters] [attribute_list] [DETAIL] [ORDER BY order_by_attribute_list] [LIMIT integer]
DBMCLI> LIST DBSERVER DETAIL

Disk drive firmware version :

cellcli -e "list physicaldisk where disktype=harddisk attributes slotnumber,makemodel,physicalfirmware"

To check the Roce switch version :

ssh admin@oraexa01sw-rocea0 show version | grep "System version:"
ssh admin@oraexa02sw-rocea0 show version | grep "System version:"

ILOM Commands :
===============
SP => ILOM 
SYS => Host 
ssh  oraexa02dbadm01-ilom
> help
1) Version => Version details by running the version command from the shell prompt
-> version
2) faults  => To view a tabular output of faulty system targets, properties and values
> show faulty
3) Power => To view the total system power consumptions from CLI.
-> show /SP/porwermgmt actual_power 
4) Hard Reboot => To reboot the host server power statement
 -> reset /SYS
5) Force Shutdown => To immediately shut down power of the remote host server 
-> stop -force /SYS
6) Graceful Shutdown => To shut down the OS gracefully prior to powering off the host server
-> stop /SYS
7) Power On => To turn on full power to the remote host server 
-> start /SYS

User administration 
-------------------
-> show /SP/users      [Display all the ILOM user]
-> show /SP/user/admin  [Display configuration settings of a specific user]
-> create /SP/users/user_name password=PWD role=[administrator|operator]    [Create new user]
-> delete /SP/users/username    [Delete a user]
-> set /SP/users/admin01 role=administrator   [set the role of a user]
-> set /SP/users/admin01  [set or change password of user]

ILOM Event log :
----------------
-> show /SP/logs/event/list

List all the hardware faults :
------------------------------
-> show -level all -output table /SP/faultmgmt

List all temperature sensor readings :
--------------------------------------
-> show -level all -output table /SYS type==Temperature value

Hardware info 
show DIMMS
-> show -level all -output table /SYS type==DIMM
show CPUS 
-> show -level all -output table /SYS type=='Host Processor'
show disks
-> show -l all /SYS type=='Hard Disk'



How to know how many physical core enabled on the exadata.
----------------------------------------------------------
In the below example out of 48 core 48 core are enabled . IF it is show like 16/48 then 16 cores are enabled. 
CPUCount shows the logical cpu as intel cpu are hyperthreaded means (1 physical core are 2 virtual thread)48 cores are 96 thread.  In Database also we can see that 96 as CPU_COUNT parameter . 
DBMCLI> list dbserver detail
         name:                   oraexa01db01
         bbuStatus:              normal
         coreCount:              48/48
         cpuCount:               96/96
 
Exawatcher report :
login as a root user
cd /opt/oracle.ExaWatcher/
./GetExaWatcherResults.sh --from 12/13/2023_07:00:00 --to 12/13/2021_10:00:00 
ExaWatcher Utility On Exadata Compute and Storage Nodes (Doc ID 1617454.1)
################################################################################################################################### 
Cloud database commands/ OCI :
==========================
dbcli describe-component
dbcli describe-latestpatch
dbcli list-dbhomes
dbcli get-dbsystem-nodeinfo
dbcli describe-system
dbcli describe-system -d

/opt/oracle/dcs/bin/dbcli ping-agent
/opt/oracle/dcs/bin/dbcli ping-admin
systemctl status initdcsagent
systemctl status initdcsadmin
systemctl status iptables
systemctl status firewalld
systemctl status mysqld

Please provide the following information taken as root.
1.
#script /tmp/dbcli_details_`hostname`.log
curl -s http://169.254.169.254/opc/v1/instance/ | egrep -v "user_data|ssh_authorized_keys|timeCreated"
curl -s http://169.254.169.254/opc/v1/instance/ | egrep -v "user_data|ssh_authorized_keys|timeCreated"

export DEVMODE=true
dbcli get-dbsystem-nodeinfo
dbcli describe-component
dbcli describe-system
dbcli list-jobs
dbcli describe-job -i "9112b3a6-0a38-46e9-9436-f79b9d2212ca"
yum history

/u01/app/19.0.0.0/grid/bin/crsctl status resource -t

rpm -qa | egrep -i 'dbaas|exa|dcs'
export PATH=/opt/oracle/dcs/bin:.:$PATH
dbcli describe-system -d
cliadm update-dbcli
dbcli describe-component
dbcli describe-latestpatch
dbcli list-databases -j
dbcli list-dbhomes
dbcli list-databases
dbcli describe-database -i e946738f-c77a-46a7-90cc-733df54a4154 -j
dbcli list-objectstoreswifts

dbcli list-pdbs -i <DB ID> -j #### replace <DB ID> with the DB ID listed by the previous command
dbcli list-jobs
dbcli describe-job -i "9112b3a6-0a38-46e9-9436-f79b9d2212ca"
dbcli list-dataguardstatus
dbcli list-backupconfigs
dbcli list-objectstoreswifts
dbcli get-dbsystemsecurestatus
dbcli get-availableospatches
exit

Below diag script will give in details information  : 

Login to the VM
# sudo su -
# cd /tmp
# wget https://objectstorage.us-ashburn-1.oraclecloud.com/p/-K-EPXQHr7NA8bHZv3vLZAfqYETOokYwBEPkY2HiSWEeaA3PqOXvOAUyF3ngDR-Z/n/dbcloudoci/b/BaseDbSupport/o/basedb_diag_collection.sh
# chmod 750 basedb_diag_collection.sh
Usage:
~~~~~~
# ./basedb_diag_collection.sh 2>&1 | tee basedb_diag_collection_$(date +"%m%d%Y%H%M%S").log
And then attach the log to the SR. We will review the logs and get back to you with our analysis.

Also please use the following command to zip and upload the log files

# cd /tmp
# sudo tar -czf dcs_`hostname`_`date +"%Y-%m-%d_%H%M%S"`.tar.gz /opt/oracle/d



2. TFA output for 3-4 hours covering the period of the error.
# tfactl diagcollect -all -from "Mon/DD/2023 HH24:00:00" -to "Mon/DD/2023 HH24:59:59"
tfactl diagcollect -all -from "OCT/17/2023 00:00:00" -to "OCT/17/2023 23:59:59"

[In TFA 22.3.0 version or later, Smart Problem Classification is enabled by default when you run tfactl diagcollect. ref: Doc ID 2914105.1 )]
A) Disable the smartprobclassifier
tfactl set smartprobclassifier=off

B) collect the log for specified time
tfactl diagcollect -from "FEB/04/2025 22:00:00" -to "FEB/05/2023 01:10:00" <<< Please change the timeframe as per issue timeframe.

C) enable the smartprobclassifier
tfactl set smartprobclassifier=on


[root@dfapc bin]# dbcli list-databases -j
[ {
"id" : "386d08fa-8130-46a4-a5c5-267317fb1280",
"name" : "DFAPC",
"dbName" : "DFAPC",
"databaseUniqueName" : "DFAPC_iad1nz",
"dbVersion" : "18.6.0.0.190416",
"dbHomeId" : "6c6eee92-8f46-41af-9fb5-e31137e40688",
"instanceOnly" : false,
"instanceOnly" : false,
"instanceOnly" : false,
"registerOnly" : falser
"dbId" : "3105411633",
"isCdb" : true,
"isAutoBackupDisabled" : true,
"pdBName" : "DFAP",
"pdbAdminUserName" : "pdbuser",
"enableTDE" : true,
"dbType" : "SI",
"dbTargetNodeNumber" : "0",
"dbClass" : "OLTP",
"dbShape" : null,
"dbStorage" : "ASM",
"dbRedundancy" : null,
"dbCharacterSet" : {
"characterSet" : "AL32UTF8",
"nlsCharacterset" : "AL16UTF16",
"dbTerritory" : "AMERICA",
"dbLanguage" : "AMERICAN"
},
"dbConsoleEnable" : false,
"backupConfigId" : "519e7b5a-f790-44ec-bc1b-829384406b5c",
"backupDestination" : "NONE",
"cloudStorageContainer" : null,
"state" : {
"status" : "CONFIGURED"
},
"createTime" : "July 04, 2019 20:40:46 PM UTC",
"updatedTime" : "July 04, 2019 21:54:19 PM UTC",
"rmanBkupPassword" : null,
"dbEdition" : "SE",
"dbDomainName" : "prod.dfa.oraclevcn.com",
"level0BackupDay" : "sunday",
"isBcfgInSync" : true,
"logRetentionDays" : 30
} ]

//check dbcli jobs
dbcli list-jobs
https://medium.com/@harjulthakkar/oracle-database-cloud-service-useful-cli-part1-34a4e6e89a76
https://techgoeasy.com/dbcli-commands/

dbaascli database backup --dbname ritm01 --start --level0
systemctl start dbcsagent.service
systemctl start dbcsadmin.service
dbaascli database backup --dbname HYPN001 start
/var/opt/oracle/bkup_api/bkup_api bkup_start --dbname=HYPN1

/var/opt/oracle/bkup_api/bkup_api list jobs --all --dbname=EUDWHP2_lhr34f
/var/opt/oracle/bkup_api/bkup_api get_config_info --all --dbname EUDWHP2_lhr34f

dbcli list-backupconfigs
ID                                       Name                 RecoveryWindow   CrosscheckEnabled   BackupDestination
---------------------------------------- -------------------- ---------------- ------------------- --------------------
41919e67-eef5-4796-bd11-91bd6cc7edd3     bz3CiaxTfxoMUIIRGwPf_BC 30               true                ObjectStore

dbcli describe-backupconfig -i 6842aa39-b8c7-4ae9-9fc3-eadf93a226af
dbcli describe-backupconfig -i <id> -in <name>
[root@oasn1c ~]# dbcli describe-backupconfig -i 41919e67-eef5-4796-bd11-91bd6cc7edd3
Backup Config details
----------------------------------------------------------------
                     ID: 41919e67-eef5-4796-bd11-91bd6cc7edd3
                   Name: bz3CiaxTfxoMUIIRGwPf_BC
      CrosscheckEnabled: true
         RecoveryWindow: 30
      BackupDestination: ObjectStore
         BackupLocation: bz3CiaxTfxoMUIIRGwPf
          ObjectStoreId: c1ea397e-948f-43b0-afb2-124f6bedab69
            CreatedTime: January 9, 2019 11:11:12 AM UTC
            UpdatedTime: January 9, 2019 11:11:17 AM UTC
       LocationAffinity:
            RecoveryTag:

dbcli list-jobs | grep -i <dbname>
dbcli describe-job -i <job_ID> -j
9f4c4e94-28a7-4daf-9a78-06edb62158f5
You can find the job ID in this file by using the timestamp returned by the job report in step 2

We can get more information of the failure in /opt/oracle/dcs/log/dcs-agent.log

If the problem details suggest an RMAN issue, review the RMAN logs in the following directory.
/opt/oracle/dcs/log/<hostname>/rman/bkup/<db_unique_name>/rman_backup/<yyyy-mm-dd>

Check for the mysqld service if backup is failing.
systemctl status mysqld

Database Service Agent Issues :
OCI database makes use of an agent framework to allow you to manage your database through the cloud platform. Occasionally you might need 
to restart the dcsagent program if it has the status of stop/waiting to resolve a backup failure.
For OL7 and above Operating system
	1. From a command prompt, check the status of the agent:
		systemctl status initdcsagent
	2. If the agent is in the stop/waiting state, try to restart the agent:
		systemctl start initdcsagent
	3. Check the status of the agent again to confirm that it has the start/running status:
		systemctl status initdcsagent
		systemctl stop initdcsagent

For OL6 Operating system
    # initctl status initdcsagent
    # initctl stop initdcsagent
    # initctl start initdcsagent
    # initctl status initdcsagent
   


Cleanup job in OCI : 
--------------------
[root@mceprdc log]# dbcli list-logCleanJobs
DCS-10032:Resource LogCleanupSummary is not found.
[root@mceprdc log]# dbcli list-logSpaceUsage

              Timestamp:  February 8, 2023 6:54:27 PM UTC
----------------------------------------------------------------
Component            Size(MB)             Partition            LogUsagePercentage   PartitionFreePercentage
-------------------- -------------------- -------------------- -------------------- --------------------
dcs                  3886.00              /dev/mapper/VolGroupSys4-LogVolRoot 11.06                11.00
database             4392.96              /dev/mapper/BITS_GRP-BITS 2.18                 24.00


Exacs :
========
To get the details of the server metadata :
 curl -s http://169.254.169.254/opc/v1/instance/ | egrep -v "user_data|ssh_authorized_keys|timeCreated"

tfactl diagcollect -all -from "FEB/12/2024 00:00:00" -to "FEB/12/2024 10:00:00"

ADW :
======
check for the alert log :

select ORIGINATING_TIMESTAMP,PROCESS_ID,MESSAGE_TEXT, MESSAGE_ARGUMENTS from v$diag_alert_ext order by ORIGINATING_TIMESTAMP DESC;

Check for the contents of the tracefile as below: 

col payload format a4000
set lines 4000 pages 0
set trimspool on
spool exd1pod8_j00z_209402.trc
select PAYLOAD from V$DIAG_TRACE_FILE_CONTENTS where TRACE_FILENAME='exd1pod8_j00z_209402.trc' order by line_number;
spool off
 
################################# ################################# ################################# ################################# 
RAC Commands:
=============

srvctl start instance -d IFSLIVEC -i IFSLIVEC1
srvctl start instance -d mstrdb -i mstrdb2
To add service in PDB :

srvctl add service -db cpdb -service hr1 -pdb pdb1 -preferred cpdb1 -available cpdb2
SELECT NAME, PDB FROM all_services;

srvctl stop database -d DB_NAME -o immediate
srvctl stop database -d DB_NAME -o abort
srvctl stop instance -d <db uniq name> -i SAS1
srvctl start instance -d <db uniq name> -i SAS1
srvctl stop asm -n NODE_NAME -o immediate
srvctl start asm -n NODE_NAME 
srvctl status asm -n NODE_NAME 
srvctl config asm -n NODE_NAME 

srvctl status service -d db_name
srvctl config service -d db_name
srvctl start service -d dbname -s service_name
srvctl stop service -d dbname -s service_name
srvctl add service -d {DB_NAME} -s {SERVICE_NAME} -r {"preferred_list"} -a {"available_list"} [-P {BASIC | NONE | PRECONNECT}]
srvctl relocate service -d db_name -s service_name -i instance_name -t new_instance_name [-f]

srvctl status nodeapps -n nodename
srvctl config nodeapps -n nodename

An example of stopping an instance in a policy-managed database is:
$ srvctl stop instance -db crm -node node1

srvctl stop instance -db TESTX2 -node oraexa02db02
srvctl disable instance -db TESTX2 -instance TEST2


An example of stopping an instance in an administrator-managed database is:
$ srvctl stop instance -db crm -instance "crm1"


srvctl status asm -n UKLONOR02
crsctl stat res -t
crsctl stop crs -f
Crsctl 
crs_stat -t
crs_start -f ora.uklonor02.ASM2.asm
crs_stop ora.uklonor02.ASM2.asm
crs_stat -t ora.REPORT.REPORT2.inst
crs_stop -f ora.REPORT.REPORT2.inst
crs_stop -f ora.OLAP.OLAP1.inst
crs_start -t ora.REPORT.REPORT2.inst
crs_stat  ==> Give the status of the resources
crs_stop -f 


STOP & START CRS: ( run from root user):
$GRID_HOME/bin/crsctl stop crs $GRID_HOME/bin/crsctl start crs

CRS Start in exclusive mode :
	crsctl start crs -excl -nocrs
Stop CRS Forcefully :
	crsctl stop crs -f

Enable/Disable auto restart of CRS.
$GRID_HOME/bin/crsctl disable crs $GRID_HOME/bin/crsctl enable crs

Find the cluster name
$GRID_HOME/bin/cemutlo -n
$GRID_HOME/bin/olsnodes -c

Find grid version:
$GRID_HOME/bin/crsctl query crs softwareversion <hostname)
$GRID_HOME/bin/crsctl query crs softwareversion host-dbaclass1

check cluster component status
$GRID_HOME/bin/crsctl stat res -t
$GRID_HOME/bin/crsctl stat res -t -init
$GRID_HOME/bin/crsctl check crs
$GRID_HOME/bin/crsctl check cssd
$GRID_HOME/bin/crsctl check crsd
$GRID_HOME/bin/crsctl check evmd

Find voting disk location
$GRID_HOME/bin/crsctl query css votedisk

Find OCR location:
$GRID_HOME/bin/ocrcheck

Find cluster interconnect details
$GRID_HOME/bin/oifcfg getif

app-ipmp0 172.21.39.128 global public
loypredbib0 172.16.3.192 global cluster_interconnect
loypredbib1 172.16.4.0 global cluster_interconnect

select NAME,IP_ADDRESS from v$cluster_interconnects;
NAME 			IP_ADDRESS
————— 			—————-
loypredbib0 	172.16.3.193
loypredbib1 	172.16.4.1

Check active version of cluster :
crsctl query crs activeversion

Oracle Clusterware active version on the cluster is [12.1.0.2.0]

Stop and start high availability service ( HAS)

crsctl stop has
crsctl start has

Check CRS status of remote nodes :

crsctl check cluster
crsctl check cluster -all

Disk timeout from node to voting disk(disktimeout) :

crsctl get css disktimeout

CRS-4678: Successful get disktimeout 200 for Cluster Synchronization Services.

Network latency in the node interconnect (Misscount) :

crsctl get css misscount

CRS-4678: Successful get misscount 30 for Cluster Synchronization Services.

Move voting disk to another diskgroup:

crsctl replace votedisk +OCRVD

Successful addition of voting disk 2e4ded6cee504fc8bf078b080fb7be6f.
Successful addition of voting disk 8e87826024e24fffbf5add65c011fc66.
Successful addition of voting disk e1ba56dedff84fa8bf5605e0302fc81e.
Successful deletion of voting disk 2b7ce864c44d4fecbf60885a188290af.
Successfully replaced voting disk group with +OCRVD.
CRS-4266: Voting file(s) successfully replaced

Add another voting disk :

crsctl add css votedisk

18. Delete voting disk:

crsctl delete css votedisk

19. Get ocr disk backup details

ocrconfig -showbackup

20. Check whether standard or flex ASM

crsctl get cluster mode status

Cluster is running in “standard” mode

21. Check CRS configuation

crsctl config crs

22. crsctl has commands for standalone grid infrastrcuture

crsctl check has
crsctl config has
crsctl disable has
crsctl enable has

crsctl query has releaseversion
crsctl query has softwareversion

crsctl start has
crsctl stop has


Export and Import :
====================

set lines 200 pages 200
col owner for a10
col object_name for a29
select owner,object_name,object_type from dba_objects where object_name in ('FND_FLEX_VALUE_SETS','FND_FLEX_VALUE_HIERARCHIES','FND_FLEX_VALUES','QBE_HIERARCHY_MV');
set lines 200 pages 200
col owner for a30
col object_name for a29
select owner,object_type,status,count(*) from dba_objects where owner='&owner' group by owner,object_type,status ;

set lines 200 pages 200
col segment_name for a30
col owner for a10
select owner,segment_name,sum(bytes)/1024/1024 SIZE_IN_MB from dba_segments where segment_name in ('FND_FLEX_VALUE_SETS','FND_FLEX_VALUE_HIERARCHIES','FND_FLEX_VALUES','QBE_HIERARCHY_MV') group by owner,segment_name;

set lines 200 pages 200
COLUMN owner FORMAT A20
COLUMN directory_name FORMAT A25
COLUMN directory_path FORMAT A80
SELECT * FROM dba_directories ORDER BY owner, directory_name;
SELECT * FROM dba_directories where directory_name='&Directory_name' ORDER BY owner, directory_name;
set lines 200 pages 200
col owner for a30
col object_name for a29
select owner,object_type,status,count(*) from dba_objects where owner='&owner' group by owner,object_type,status order by owner,object_type,status;
select owner,sum(bytes)/1024/1024/1024 SIZE_IN_GB from dba_segments where owner in ('&OWNER') group by owner order by 2;
select owner,tablespace_name,count(*) from dba_segments where owner in ('&OWNER') group by owner,tablespace_name;

export ORACLE_PDB_SID=PQBEITP

expdp \'/ as sysdba\' directory=EXP_DCES_FRANCE logfile=exp_dces_france_${EXP_TIME}.log dumpfile=exp_dces_france_${EXP_TIME}_%U.dmp flashback_time=systimestamp schemas=dces_france estimate=blocks

expdp \'/ as sysdba\' tables=XXQBE_DPL_STAGE.STG_MAPPINGS directory=IN68609 dumpfile=expdp_STG_MAPPINGS.dmp logfile=expdp_STG_MAPPINGS.log 

impdp \'/ as sysdba\' tables=XXQBE_DPL_STAGE.STG_MAPPINGS directory=IN68609 dumpfile=expdp_STG_MAPPINGS.dmp TABLE_EXISTS_ACTION=TRUNCATE logfile=impdp_STG_MAPPINGS.log 

CREATE DIRECTORY IN72798 AS '/mnt/qbe-prd-dmp/IN72798';

export DATE=$(date +%y-%m-%d_%H%M%S)
expdp "SYS/titanic" schemas=FINANCE exclude=TABLE:"= 'TEMP'",INDEX,CONSTRAINTS directory=TEST_DP compression=all dumpfile=FINANCE_expdump.dmp logfile=expdp_FINANCE_expdump.log
expdp system/aliens schemas=DIMENSIONS directory=TEST_DP dumpfile=DIMENSIONS_30052022.dmp logfile=expdp_DIMENSIONS_30052022.log
expdp sys/titanic PARFILE=E:\DUMP\FINANCE.par
FINANCE.par
schemas=FINANCE 
exclude=TABLE:"= 'TEMP'",INDEX,CONSTRAINTS 
directory=TEST_DP 
compression=all 
dumpfile=FINANCE_expdump.dmp 
logfile=expdp_FINANCE_expdump.log

50 GB ko 15 min on object storage 
expdp \'/ as sysdba\' parfile=IN70416.par
vi XXQBE_RO_apac_fact_table.par
userid="admin/dh_new57PBBq47M_pawdf@pqbei3adw_medium"
DIRECTORY=data_pump_dir
parallel=5
dumpfile=default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/ADW_PROD/o/XXQBE_RO_apac_fact_table_12FEB2025_%u.dmp
filesize=5g
logfile=exp_XXQBE_RO_apac_fact_table_12FEB_2025.log
exclude=statistics
tables=XXQBE_RO.apac_fact_table
LOGTIME=ALL
METRICS=Y



XXQBE_FDW_TGT.par
userid="admin/dh_new57PBBq47M_pawdf@pqbei3adw_medium"
DIRECTORY=data_pump_dir
parallel=4
dumpfile=default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_1_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_2_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_3_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_4_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_5_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_6_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_7_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_8_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_9_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_10_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_11_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_12_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_13_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_14_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_15_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_16_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_17_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_18_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_19_%u.dmp, default_credential:https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/XXQBE_FDW_TGT_11Aug24_20_%u.dmp
filesize=5g
schemas=XXQBE_FDW_TGT
LOGTIME=ALL
METRICS=Y

set lines 200 pages 200
column owner format a15
column credential_name format a25
column username format a25
column enabled format a10
select * from dba_credentials;

select * from DATABASE_PROPERTIES  where PROPERTY_NAME='DEFAULT_CREDENTIAL';

PROPERTY_NAME        PROPERTY_VALUE                           DESCRIPTION
-------------------- ---------------------------------------- ----------------------------------------
DEFAULT_CREDENTIAL   ADMIN.EXP_CRED_ADW_TAB                   Default credential object name


set lines 200 pages 200
column object_name format a30
column bytes format 9999999
select object_name, bytes from dbms_cloud.list_objects('EXP_CRED_ADW_TAB','https://objectstorage.ap-sydney-1.oraclecloud.com/n/sd2oaxww9vg2/b/REFRESH_DEV3/o/');


expdp "SYS/olapsyst" schemas=WFM  directory=TEST_DP dumpfile=WFM_16062022_new.dmp logfile=expdp_WFM_16062022_new.log compression=all 

export ORACLE_PDB_SID=EQPRD
export EXP_TIME=$(date +%d_%m_%y)
nohup expdp \'/ as sysdba\' directory=IN29620 logfile=XXQBE_DPL_TARGET_${EXP_TIME}.log dumpfile=XXQBE_DPL_TARGET_${EXP_TIME}_%U.dmp parallel=4 schemas=XXQBE_DPL_TARGET estimate=blocks &
expdp \'/ as sysdba\' directory=IN45044 logfile=AAPEN_IN45044_${EXP_TIME}.log dumpfile=AAPEN_IN45044_${EXP_TIME}_%U.dmp tables=AAPEN.DREAMARCHIVE,AAPEN.PRICINGSCH

nohup expdp \'/ as sysdba\' directory=IN45044 logfile=AAPEN_IN45044_${EXP_TIME}.log dumpfile=AAPEN_IN45044_${EXP_TIME}_%U.dmp  tables=XQBE.QBE_HIERARCHY_MV,APPLSYS.FND_FLEX_VALUE_SETS,APPLSYS.FND_FLEX_VALUE_HIERARCHIES,APPLSYS.FND_FLEX_VALUES &
export ORACLE_PDB_SID=EQQA
export IMP_TIME=$(date +%d_%m_%y)
nohup impdp \'/ as sysdba\' directory=IN40257 logfile=APPLSYS_IN40257_${IMP_TIME}.log dumpfile=APPLSYS_IN40257__01.dmp  tables=XQBE.QBE_HIERARCHY_MV,APPLSYS.FND_FLEX_VALUE_SETS,APPLSYS.FND_FLEX_VALUE_HIERARCHIES,APPLSYS.FND_FLEX_VALUES TABLE_EXISTS_ACTION=TRUNCATE &

select owner,sum(bytes)/1024/1024/1024 SIZE_IN_GB from dba_segments group by owner order by 2;
select owner,tablespace_name,count(*) from dba_segments where owner in ('&OWNER') group by owner,tablespace_name;

Trobulshooting expdp :
DataPump Export (EXPDP) Performance Known Problems (Doc ID 1941760.1)
SELECT sl.sid, sl.serial#, sl.sofar, sl.totalwork, dp.owner_name, dp.state, dp.job_mode 
FROM v$session_longops sl, v$datapump_job dp WHERE sl.opname = dp.job_name AND sl.sofar != sl.totalwork;

set lines 200 pages 200
col owner_name for a20
col state for a20
col job_mode for a20
col message for a30
SELECT sl.sid, sl.serial#, sl.sofar, sl.MESSAGE,sl.totalwork, dp.owner_name, dp.state, dp.job_mode 
FROM v$session_longops sl, v$datapump_job dp WHERE sl.opname = dp.job_name;



################################# APEX / TOMCAT :
Admin user passwprd change : 
select owner,object_name from dba_objects where object_name='WWV_FLOW_FND_USER';


set lines 200 pages 200
COLUMN user_id Format 99999999999999999
COLUMN first_name FORMAT A20
COLUMN last_name FORMAT A20
COLUMN default_schema FORMAT A30
col EMAIL_ADDRESS for a30
SELECT user_id, first_name, last_name, default_schema, EMAIL_ADDRESS FROM APEX_220200.wwv_flow_fnd_user WHERE  user_name = 'ADMIN' ORDER BY last_update_date DESC;

ALTER SESSION SET CURRENT_SCHEMA = APEX_220200;

UPDATE APEX_220200.wwv_flow_fnd_user SET web_password = 'GSte63#qt6#5GH' WHERE  user_name = 'ADMIN' AND user_id = 1407291715826985;

commit;

BEGIN
  WWV_FLOW_SECURITY.g_security_group_id := 10;
  WWV_FLOW_FND_USER_API.unlock_account('ADMIN');
  COMMIT;
END;
/

How to get the tomcat version :

[tomcat@skat1a1 bin]$ pwd
/u01/appx/tomcat/version/bin
[tomcat@skat1a1 bin]$ ./version.sh


How to Check Patches Applied to APEX (Doc ID 2233459.1)

To get the apex user details;
select owner,object_name from dba_objects where object_name='WWV_FLOW_PLATFORM_PREFS';
OWNER                    OBJECT_NAME
----------------------  ----------------------------------------------------------
APEX_050100              WWV_FLOW_PLATFORM_PREFS

SQL> select username from dba_users where username like 'APEX%';

USERNAME
--------------------------------------------------------------------------------
APEX_050100
APEX_INSTANCE_ADMIN_USER
APEX_LISTENER
APEX_PUBLIC_USER
APEX_REST_PUBLIC_USER


APEX Version :
SQL> SELECT VERSION_NO FROM APEX_050100.APEX_RELEASE;

VERSION_NO
--------------------------------------------------------------------------------
5.1.4.00.08

To get the patching details of the Apex :

select name,value from APEX_050100.WWV_FLOW_PLATFORM_PREFS where name like 'APEX_5_1_4_PATCH_%' ;


select OWNER,JOB_NAME,LAST_START_DATE,LAST_RUN_DURATION,NEXT_RUN_DATE,COMMENTS,JOB_CREATOR,PROGRAM_NAME,JOB_TYPE,JOB_ACTION,SCHEDULE_OWNER,
 SCHEDULE_NAME,SCHEDULE_TYPE,START_DATE,REPEAT_INTERVAL,ENABLED,STATE,FAILURE_COUNT from DBA_SCHEDULER_JOBS order by LAST_START_DATE desc;
 
 
SELECT patch_id, status FROM dba_registry_sqlpatch;

COL PATCH_ID    FORMAT 999999999
COL PATCH_UID   FORMAT 999999999
COL VERSION     FORMAT a10
COL ACTION      FORMAT a10
COL STATUS      FORMAT a10
COL ACTION_TIME FORMAT a30
COL DESCRIPTION FORMAT a45
SELECT PATCH_ID,PATCH_UID,VERSION,ACTION,STATUS,ACTION_TIME,DESCRIPTION FROM dba_registry_sqlpatch;

./datapatch -verbose

ACL :
=====
col HOST for a50
col ACL for a50
col ACL_OWNER for a20
select * from dba_network_acls;


ACFS :
=======
Top issues(RAC): ACFS File System Cannot be Mounted or Unmounted (Doc ID 2245041.1)
What diagnostic information to collect for ADVM/ACFS related issues (Doc ID 885363.1)
ASM/ACFS 11.2 How To Create “A CRS Managed" ACFS FileSystem On a Cluster RAC Configuration Through the ASMCA Assistance Or Command-Line (Doc ID 1484221.1)

A) Dismount all the ACFS filesystems running in the cluster as follows (as root user):
# srvctl stop filesystem -d volume_device_name [-n node_name] [-f]
-d  <volume_device_name>  :The Oracle ACFS volume device name
-n  <node_name>  : The name of a node (If you do not specify this option, then the utility stops the volume resource on all active nodes in the cluster.)
-f  : This option stops the file system and also stops any databases or other resources that depend on this file system.
Example:
[root@asmgrid1 ~]# df -k | grep asm
/dev/asm/volnew1-347  14680064    159700  14520364   2% /u01/app/grid/acfsmounts/acfsdgnew_volnew1
/dev/asm/vol_oh1-115  35651584   4590104  31061480  13% /u04acfs
#  srvctl stop filesystem -d  /dev/asm/volnew1-347   -f
#  srvctl stop filesystem -d  /dev/asm/vol_oh1-115   -f

B) Make sure the ACFS filesystem(s) was/were dismounted on all the nodes:
# df -k | grep asm

C) Then perform the steps described in the following document:
Steps To Shutdown/Startup The CRS, OHAS, ASM & RDBMS Services on RAC 11.2 Configuration. (Doc ID 1355977.1)
srvctl start filesystem -d /opt/oracle/dcs/commonstore
asmcmd volinfo --all
ASMCMD> volinfo --all
ASMCMD> volinfo -G DATA -a
ASMCMD> volenable -G DATA COMMONSTORE
ASMCMD [+] > volenable -G DATA volume1
ASMCMD [+] > volenable -G DATA volume1,volume2,volume3
ASMCMD [+] > volenable -G DATA1,DATA2 volume1,volume2,volume3

/sbin/acfsutil info fs /u02/app/oracle/oradata/commondfs
/sbin/acfsutil snap info /u02/app/oracle/oradata/datastore
[root@GRP-PRD-DB-MK2 commondfs]# acfsutil snap info /u02/app/oracle/oradata/commondfs
snapshot name:               grpprdMK
snapshot location:           /u02/app/oracle/oradata/commondfs/.ACFS/snaps/grpprdMK
RO snapshot or RW snapshot:  RW
parent name:                 /u02/app/oracle/oradata/commondfs
snapshot creation time:      Tue Dec 16 09:51:38 2014

    number of snapshots:  1
    snapshot space usage: 1085439356928  ( 1010.89 GB )

https://ermanarslan.blogspot.com/2017/02/oda-x6-2-using-acfs-snapshots-for.html

srvctl status filesystem -volume /dev/asm/commonstore-213
/sbin/acfsutil info fs

PRCT-1011 : Failed to run "advmutil". Detailed error: /opt/oracle/dcs/commonstore
/sbin//advmutil: line 8: pp/grid: No such file or directory

acfsdriverstate version
acfsroot version_check
acfsdriverstate supported


Get the SID from the request id :
=================================
SELECT d.inst_id,a.request_id,
d.sid as Oracle_SID,
d.serial#,
d.osuser,
d.process,
d.sql_id,
c.SPID
FROM apps.fnd_concurrent_requests a,
apps.fnd_concurrent_processes b,
gv$process c,
gv$session d
WHERE a.controlling_manager = b.concurrent_process_id
AND c.pid = b.oracle_process_id
AND b.session_id=d.audsid
AND a.request_id='&request_id'
AND a.phase_code='R';


Performance Tuning :
====================
http://www.br8dba.com/tag/sql-tuning-advisor/#7
select B.SQL_FULLTEXT from V$SQL B WHERE B.SQL_ID='&SQL_ID';
select B.SQL_TEXT from dba_hist_sqltext B WHERE B.SQL_ID='&SQL_ID';
select B.SQL_ID,B.SQL_TEXT from dba_hist_sqltext B WHERE SQL_TXT like (%%)

Blocking session :
------------------
https://www.ktexperts.com/oracle-important-queries-to-check-blocking-sessions-securecrt/

set lines 400 pages 200;
column SID               format 999999;
column serial            format 999999;
column P1                format 999999999999;
column P2                format 999999999999;
column P3                format 999999999999;
column EVENT             heading 'Wait|Event'    format a30;
column USERNAME          heading 'User|Name'     format a10 truncate;
column WAIT_CLASS        heading 'Wait|Class'    format a5  truncate;
column blocker_chain_id  heading 'Blkng|Chn|ID'  format 99;
column NUM_WAITERS       heading 'Blkd|Sess'     format a10;
column INST_ID           heading 'I_#'           format 99;
column IN_WAIT_SECS      heading 'Secs|in|Wait'  format 999,999;
column CHAIN_ID          heading 'Chn|ID'        format 99;
select /*+ oracleblogwriter.com OEM_TOOLKIT blocking_sessions */ lpad( '  ' , LEVEL, '    ' ) ||s.USERNAME as username,RPAD( '  ' , LEVEL , '        ' ) ||wc.num_waiters as num_waiters, wc.sid sid, wc.sess_serial# as SERIAL, s.INST_ID, s.sql_id, s.prev_sql_id, decode(s.wait_class,'Application','APPL', 'Other','OTHR', 'Idle','IDLE', 'Concurrency','CONCR', 'Cluster','CLSTR', 'Administrative','ADMN', 'User I/O','U_IO', 'System I/O','S_IO', 'Configuration','CONFIG') as wait_class, s.event, wc.P1, wc.P2, wc.P3, wc.IN_WAIT_SECS, blocker_chain_id, chain_id from 
v$wait_chains wc, gv$session s, gv$session bs, gv$instance i, gv$process p 
WHERE wc.instance = i.instance_number (+) AND (wc.instance = s.inst_id (+) and wc.sid = s.sid (+)  and wc.sess_serial# = s.serial# (+))  AND (s.final_blocking_instance = bs.inst_id (+) and s.final_blocking_session = bs.sid (+))  AND (bs.inst_id = p.inst_id (+) and bs.paddr = p.addr (+)) AND ( num_waiters > 0 OR ( blocker_osid IS NOT NULL AND in_wait_secs > 1 ))
CONNECT BY PRIOR wc.sid=wc.blocker_sid
AND PRIOR wc.sess_serial#=wc.blocker_sess_serial#
AND PRIOR wc.instance = wc.blocker_instance START WITH wc.blocker_is_valid='FALSE'
ORDER BY wc.chain_id, LEVEL;


PROMPT ##################################################################################### 
PROMPT Blocking_session
PROMPT #####################################################################################
set head on 
set linesize 300 
select B.USERNAME ||' ('||B.SID||','||B.SERIAL#||',@'||B.INST_ID||') is Currently '||B.STATUS||' for last '||B.LAST_CALL_ET||' Sec and it''s BLOCKING user '|| W.USERNAME|| ' ('|
|W.SID||','||W.SERIAL#||',@'||W.INST_ID||')' from 
(select INST_ID,SID,SERIAL#,USERNAME,STATUS,BLOCKING_INSTANCE,BLOCKING_SESSION, LAST_CALL_ET from gv$session where BLOCKING_SESSION >0) W, 
(select INST_ID,SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET from gv$session ) B 
where W.BLOCKING_INSTANCE=B.INST_ID and W.BLOCKING_SESSION=B.SID; 
PROMPT ##################################################################################### 
PROMPT Blocking_session_event
PROMPT #####################################################################################
set linesize 300 
set pagesize 100 
col machine for a50 
col event for a50 
col username for a25 
select inst_id,sid,serial#,username,event,status,sql_id,BLOCKING_SESSION,machine from gv$session 
where event like '%lock%' or event like '%latch%' or event like '%buffer%' or event='latch: row cache objects' or event='enq: TM - contention' 
or event='enq:_TX_-_index_contention' 
and type!='BACKGROUND' order by 1; 
PROMPT ##################################################################################### 
PROMPT SQLs INVOLVED IN BLOCKING 
PROMPT #####################################################################################
set pagesize 100 
set linesize 300 
col sql_text for a100 
col SQL_ID for a30

SELECT distinct /*+ RULE */ 
  SQL_ID, sql_text 
  FROM GV$SQL 
WHERE SQL_ID IN ( 
select SQL_ID   
        from  
        (select SQL_ID from gv$session where BLOCKING_SESSION >0) 
union 
select B.SQL_ID    --Blocker Current SQL 
        from  
        (select INST_ID,SID,BLOCKING_INSTANCE,BLOCKING_SESSION from gv$session where BLOCKING_SESSION >0) W, 
        (select INST_ID,SID,SERIAL#,SQL_ID from gv$session ) B 
        where W.BLOCKING_INSTANCE=B.INST_ID and W.BLOCKING_SESSION=B.SID 
union 
select B.PREV_SQL_ID --Blocker PRIV SQL 
        from  
        (select INST_ID,SID,BLOCKING_INSTANCE,BLOCKING_SESSION from gv$session where BLOCKING_SESSION >0) W, 
        (select INST_ID,SID,SERIAL#,PREV_SQL_ID from gv$session ) B 
        where   W.BLOCKING_INSTANCE=B.INST_ID and W.BLOCKING_SESSION=B.SID 
) ORDER BY sql_id; 



set lines 750 pages 9999
col blocking_status for a102 
 select s1.inst_id,s2.inst_id,s1.username || '@' || s1.machine
 || ' ( SID=' || s1.sid || ' )  is blocking '
 || s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status
  from gv$lock l1, gv$session s1, gv$lock l2, gv$session s2
  where s1.sid=l1.sid and s2.sid=l2.sid and s1.inst_id=l1.inst_id and s2.inst_id=l2.inst_id
  and l1.BLOCK=1 and l2.request > 0
  and l1.id1 = l2.id1
  and l2.id2 = l2.id2
order by s1.inst_id;

**** Check who is blocking who in RAC, including objects

SELECT DECODE(request,0,'Holder: ','Waiter: ') || gv$lock.sid sess, machine, do.object_name as locked_object,id1, id2, lmode, request, gv$lock.type
FROM gv$lock join gv$session on gv$lock.sid=gv$session.sid and gv$lock.inst_id=gv$session.inst_id
join gv$locked_object lo on gv$lock.SID = lo.SESSION_ID and gv$lock.inst_id=lo.inst_id
join dba_objects do on lo.OBJECT_ID = do.OBJECT_ID 
WHERE (id1, id2, gv$lock.type) IN (
  SELECT id1, id2, type FROM gv$lock WHERE request>0)
ORDER BY id1, request;

select 'alter system kill session ' || '''' || sid || ',' || serial# ||',@'|| inst_id || '''' || ' immediate;' from gv$session where sid='&sid';

SELECT plan_hash_value, SUM(elapsed_time)/SUM(executions) avg_et_secs  FROM gv$sql WHERE sql_id = '&sql_id' AND executions > 0 GROUP BY plan_hash_value;
SELECT plan_hash_value, SUM(elapsed_time_total)/SUM(executions_total) avg_et_secs FROM dba_hist_sqlstat WHERE sql_id = '&sql_id' GROUP BY plan_hash_value;

	   
	   
Get the details of tables and index used in SQL_ID and there stats details / STALE :
=============================================================================
set line 150
set pages 200
col owner for a25
col object_name for a40
col sql_text for a120
set long 9999999
set line 200
col PARTITION_NAME for a25
select owner,table_name as object_name,PARTITION_NAME, object_type,last_analyzed,num_rows,STALE_STATS,STATTYPE_LOCKED from ( select owner,table_name,PARTITION_NAME,'TABLE' as object_type,last_analyzed,num_rows,STALE_STATS,STATTYPE_LOCKED from dba_tab_statistics where table_name in (select OBJECT_NAME from  gv$sql_plan where sql_id='&sql_id' and object_owner is not null and OBJECT_NAME is not null and object_type is not null) and STALE_STATS='YES'
union
select owner,index_name,PARTITION_NAME,'INDEX' as object_type,last_analyzed,num_rows,STALE_STATS,STATTYPE_LOCKED from dba_ind_statistics where index_name in (select OBJECT_NAME from  gv$sql_plan where sql_id='&sql_id' and object_type='INDEX' and object_owner is not null and OBJECT_NAME is not null and object_type is not null) and STALE_STATS='YES');

Get the details of the stat on the tables if it changed suddenly / Volume of rows count in tables increased .
-------------------------------------------------------------------------------------------------------------
col owner for a12
col object_name for a25
col object_type for a15
col subobject_name for a25
col obj# for 999999
col save_time for a20
col analyze_time for a20
select o.owner, o.object_name, o.subobject_name, th.obj#, o.object_type,
to_char(analyzetime, 'yyyy-mm-dd hh24:mi:ss') analyze_time,
rowcnt, blkcnt, avgrln, samplesize, samplesize, 
to_char(savtime, 'yyyy-mm-dd hh24:mi:ss') save_time
from sys.WRI$_OPTSTAT_TAB_HISTORY th,
dba_objects o
where
o.object_id = th.obj#
and o.owner = '&OWNER'
and o.object_name = '&OBJECT_NAME'
order by th.analyzetime desc;


Currently running query and where it is waiting :
=================================================
set lines 200 pages 200
col DTS format a22
col inst_sid heading "INST_ID|:SID" format a7
col username format a15
col machine format a12
col sql_exec_start   heading "SQL|START|D HH:MM:SS" format a11
col sql_id format a13
col module format a16
col event format a20
col SEQ# format 99990
col wait_sec heading "WAIT|(SEC)" format 99999

select inst_id||chr(58)||sid as inst_sid
   ,username
   ,case
      when machine like '%\%' then substr(machine,(instr(machine,'\',1)+1),length(machine)) -- WINDOWS HOST NAME FORMANT'
      when machine like '%.%' then substr(machine,1,(instr(machine,'.',1)-1))               -- UNIX HOST NAME FORMANT
      else machine
   end machine
   ,(sysdate - sql_exec_start) day(1) to second(0) as sql_exec_start
   ,sql_id
   ,substr(module,1,15) module
   ,substr
      (case time_since_last_wait_micro
         when 0 then (case wait_class when 'Idle' then '*IDLE* '||event else event end)
         else 'ON CPU'
         end
      ,1,33) event
   ,seq#
   ,(case time_since_last_wait_micro
      when 0 then wait_time_micro
      else time_since_last_wait_micro
      end) /1000000 wait_sec,
	  CLIENT_IDENTIFIER
from gv$session
where inst_id||chr(58)||sid <> sys_context ('USERENV','INSTANCE')||chr(58)||sys_context ('USERENV','SID')
   and username is not null -- and SID='410'
--   and status='ACTIVE' 
order by sql_exec_start,
   username,
   sql_id,
   machine,
   sid;

select B.SQL_FULLTEXT from V$SQL B WHERE B.SQL_ID='&SQL_ID';

Hot block for perticular event : 
=================================
SELECT object_name, object_type, o.object_id, COUNT(*) cnt
FROM v$active_session_history a, dba_objects o
WHERE event = '&Wait_Event'
AND a.current_obj# = o.object_id
GROUP BY object_name, object_type, o.object_id
ORDER BY cnt DESC;

SELECT object_name, object_type, o.object_id, COUNT(*) cnt
FROM v$active_session_history a, dba_objects o
WHERE event = 'gc buffer busy acquire'
AND a.current_obj# = o.object_id
GROUP BY object_name, object_type, o.object_id
ORDER BY cnt DESC;

Monitoring Progress of a SQL Execution Plan / sql query is really hanged or not :
================================================================================
http://www.br8dba.com/sql-query-is-really-hanged-or-not/

How to see the progress a query is making from within the execution plan used.
Using this we can find sql query is really hanged or not.
1. Find the active seesions

select sid, serial#, username, status, sql_id,to_char(LOGON_TIME, 'DD-MON-YYYY HH24:MI:SS') AS LOGON, event from gv$session where username='&username';
SELECT sql_id, status, sql_text FROM gv$sql_monitor WHERE  username='&username' and status not like '%DONE%';

2. Monitoring Progress of a SQL Execution Plan

column plan_line_id format 9999 heading 'LINE'
column plan_options format a10 heading 'OPTIONS'
column status format a10
column output_rows heading 'ROWS'
break on sid on sql_id on status
SELECT sid, sql_id, status, plan_line_id,
plan_operation || ' ' || plan_options operation, output_rows
FROM gv$sql_plan_monitor
WHERE status not like '%DONE%' and sid='&sid'
ORDER BY 1,4;

-- OR ---

column plan_line_id format 9999 heading 'LINE'
column plan_options format a10 heading 'OPTIONS'
column status format a10
column output_rows heading 'ROWS'
break on sid on sql_id on status
SELECT sid, sql_id, status, plan_line_id,
plan_operation || ' ' || plan_options operation, output_rows
FROM gv$sql_plan_monitor
WHERE status not like '%DONE%' 
ORDER BY 1,4;

column plan_line_id format 9999 heading 'LINE'
column plan_options format a10 heading 'OPTIONS'
column status format a10
column output_rows heading 'ROWS'
break on sid on sql_id on status
SELECT sid, sql_id, status, plan_line_id,
plan_operation || ' ' || plan_options operation, output_rows
FROM gv$sql_plan_monitor
WHERE sql_id ='&sql_id' 
ORDER BY 1,4;

Run above query multiple times to check the difference in the rows processed.
If We can see the difference then the query is not hanged.

3. REPORT_SQL_MONITOR in HTML (OR) TEXT format

SET LONG 1000000
SET LONGCHUNKSIZE 1000000
SET LINESIZE 1000
SET PAGESIZE 0
SET TRIM ON
SET TRIMSPOOL ON
SET ECHO OFF
SET FEEDBACK OFF

SPOOL report_sql_monitor.html
SELECT DBMS_SQLTUNE.report_sql_monitor(
  sql_id       => '0trz8rp78nyvw', 
  type         => 'HTML',         
  report_level => 'ALL') AS report
FROM dual;
SPOOL OFF

Execution plan :
=================
select SQL_ID,CPU_TIME,ELAPSED_TIME,CHILD_NUMBER,CHILD_ADDRESS,EXECUTIONS,ROWS_PROCESSED,TO_CHAR(LAST_ACTIVE_TIME,'DD-MON-YYYY HH24:MI:SS'), SQL_PATCH, SQL_PROFILE, SQL_PLAN_BASELINE from gv$sql where sql_id='&SQL_ID';
set echo on
set linesize 200 pagesize 1000
select * from table(dbms_xplan.display_cursor('&SQL_ID',0,'ALLSTATS LAST'));
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&SQL_ID',&CHILD_NUMBER,'ALLSTATS LAST +PEEKED_BINDS +PROJECTION +OUTLINE +PREDICATE +COST +BYTES'));
SELECT * FROM table(DBMS_XPLAN.DISPLAY_CURSOR('16puv0z6mgvnh',0,'Advanced'));


select * from table(dbms_xplan.display_awr('&SQL_ID',0,'ALLSTATS LAST +PEEKED_BINDS +PROJECTION +ALIAS +PREDICATE +COST +BYTES'));
select * from table(dbms_xplan.display);
select * from table(dbms_xplan.display(format=>'outline'));
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('16puv0z6mgvnh',0, 'ALLSTATS LAST +OUTLINE +ALIAS +QB_NAME'));

Long running quaries :
======================
set lines 200 pages 200
col DTS format a22
col inst_sid heading "INST_ID|:SID" format a7
col username format a15
col machine format a12
col sql_exec_start   heading "SQL|START|D HH:MM:SS" format a11
col sql_id format a13
col module format a16
col event format a33
col SEQ# format 99990
col wait_sec heading "WAIT|(SEC)" format 99999

select inst_id||chr(58)||sid as inst_sid
   ,username
   ,case
      when machine like '%\%' then substr(machine,(instr(machine,'\',1)+1),length(machine)) -- WINDOWS HOST NAME FORMANT'
      when machine like '%.%' then substr(machine,1,(instr(machine,'.',1)-1))               -- UNIX HOST NAME FORMANT
      else machine
   end machine
   ,(sysdate - sql_exec_start) day(1) to second(0) as sql_exec_start
   ,sql_id
   ,substr(module,1,15) module
   ,substr
      (case time_since_last_wait_micro
         when 0 then (case wait_class when 'Idle' then '*IDLE* '||event else event end)
         else 'ON CPU'
         end
      ,1,33) event
   ,seq#
   ,(case time_since_last_wait_micro
      when 0 then wait_time_micro
      else time_since_last_wait_micro
      end) /1000000 wait_sec
from gv$session
where inst_id||chr(58)||sid <> sys_context ('USERENV','INSTANCE')||chr(58)||sys_context ('USERENV','SID')
   and username is not null
   and status='ACTIVE' 
order by sql_exec_start,
   username,
   sql_id,
   machine,
   sid;
   /
/*************************************************************************
Check the ALL Active/Inactive session
**************************************************************************/

set linesize 750 pages 9999
column box format a30
column spid format a10
column username format a30 
column program format a30
column os_user format a20
col LOGON_TIME for a20  

select b.inst_id,b.sid,b.serial#,a.spid, substr(b.machine,1,30) box,to_char (b.logon_time, 'dd-mon-yyyy hh24:mi:ss') logon_time,
 substr(b.username,1,30) username,
 substr(b.osuser,1,20) os_user,
 substr(b.program,1,30) program,status,b.last_call_et AS last_call_et_secs,b.sql_id 
 from gv$session b,gv$process a 
 where b.paddr = a.addr 
 and a.inst_id = b.inst_id  
 -- and type='USER'
 and a.spid='&SPID'
 order by logon_time;

/*************************************************************************
Check the all Active session
**************************************************************************/

set linesize 750 pages 9999
column box format a30
column spid format a10
column username format a30 
column program format a30
column os_user format a20
col LOGON_TIME for a20  

select b.inst_id,b.sid,b.serial#,a.spid, substr(b.machine,1,30) box,to_char (b.logon_time, 'dd-mon-yyyy hh24:mi:ss') logon_time,
 substr(b.username,1,30) username,
 substr(b.osuser,1,20) os_user,
 substr(b.program,1,30) program,status,b.last_call_et AS last_call_et_secs,b.sql_id 
 from gv$session b,gv$process a 
 where b.paddr = a.addr 
 and a.inst_id = b.inst_id  
 and type='USER' and b.status='ACTIVE'
 order by logon_time;


/*************************************************************************
Check the ALL Active/Inactive sessions by SID
**************************************************************************/

set linesize 750 pages 9999
column box format a30
column spid format a10
column username format a30 
column program format a30
column os_user format a20
col LOGON_TIME for a20  

select b.inst_id,b.sid,b.serial#,a.spid, substr(b.machine,1,30) box,to_char (b.logon_time, 'dd-mon-yyyy hh24:mi:ss') logon_time,
 substr(b.username,1,30) username,
 substr(b.osuser,1,20) os_user,
 substr(b.program,1,30) program,status,b.last_call_et AS last_call_et_secs,b.sql_id 
 from gv$session b,gv$process a 
 where b.paddr = a.addr 
 and a.inst_id = b.inst_id  
 and type='USER' and b.SID='&SID'
-- and b.status='ACTIVE'
-- and b.status='INACTIVE'
 order by logon_time;

/*************************************************************************
Check the ALL Active/Inactive sessions by Username
**************************************************************************/

set linesize 750 pages 9999
column box format a30
column spid format a10
column username format a30 
column program format a30
column os_user format a20
col LOGON_TIME for a20  

select b.inst_id,b.sid,b.serial#,a.spid, substr(b.machine,1,30) box,to_char (b.logon_time, 'dd-mon-yyyy hh24:mi:ss') logon_time,
 substr(b.username,1,30) username,
 substr(b.osuser,1,20) os_user,
 substr(b.program,1,30) program,status,b.last_call_et AS last_call_et_secs,b.sql_id 
 from gv$session b,gv$process a 
 where b.paddr = a.addr 
 and a.inst_id = b.inst_id  
 and type='USER' and b.username='&username'
-- and b.status='ACTIVE'
-- and b.status='INACTIVE'
 order by logon_time;


/*************************************************************************
SQL Monitor
**************************************************************************/
set lines 1000 pages 9999 
column sid format 9999 
column serial for 999999
column status format a15
column username format a10 
column sql_text format a80
column module format a30
col program for a30
col SQL_EXEC_START for a20

SELECT * FROM
       (SELECT status,inst_id,sid,SESSION_SERIAL# as Serial,username,sql_id,SQL_PLAN_HASH_VALUE,
     MODULE,program,
         TO_CHAR(sql_exec_start,'dd-mon-yyyy hh24:mi:ss') AS sql_exec_start,
         ROUND(elapsed_time/1000000)                      AS "Elapsed (s)",
         ROUND(cpu_time    /1000000)                      AS "CPU (s)",
         substr(sql_text,1,30) sql_text
       FROM gv$sql_monitor where status='EXECUTING' and module not like '%emagent%' 
       ORDER BY sql_exec_start  desc
       );

/*************************************************************************
---- Sql-Monitor report for a sql_id         ( Like OEM report)
**************************************************************************/
column text_line format a254
set lines 750 pages 9999
set long 20000 longchunksize 20000
select 
 dbms_sqltune.report_sql_monitor_list() text_line 
from dual;

select 
 dbms_sqltune.report_sql_monitor() text_line 
from dual;


Blocking sessions :
==================
set linesize 300 
select B.USERNAME ||' ('||B.SID||','||B.SERIAL#||',@'||B.INST_ID||') is Currently '||B.STATUS||' for last '||B.LAST_CALL_ET||' Sec 
and it''s BLOCKING user '|| W.USERNAME|| ' ('||W.SID||','||W.SERIAL#||',@'||W.INST_ID||')' from 
(select INST_ID,SID,SERIAL#,USERNAME,STATUS,BLOCKING_INSTANCE,BLOCKING_SESSION, LAST_CALL_ET from gv$session where BLOCKING_SESSION >0) W, 
(select INST_ID,SID,SERIAL#,USERNAME,STATUS,LAST_CALL_ET from gv$session ) B 
where W.BLOCKING_INSTANCE=B.INST_ID and W.BLOCKING_SESSION=B.SID;

**** To find Blocking GOOD query 

set lines 750 pages 9999
col blocking_status for a100 
 select s1.inst_id,s2.inst_id,s1.username || '@' || s1.machine
 || ' ( SID=' || s1.sid || ' )  is blocking '
 || s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status
  from gv$lock l1, gv$session s1, gv$lock l2, gv$session s2
  where s1.sid=l1.sid and s2.sid=l2.sid and s1.inst_id=l1.inst_id and s2.inst_id=l2.inst_id
  and l1.BLOCK=1 and l2.request > 0
  and l1.id1 = l2.id1
  and l2.id2 = l2.id2
order by s1.inst_id;

**** Check who is blocking who in RAC, including objects

SELECT DECODE(request,0,'Holder: ','Waiter: ') || gv$lock.sid sess, machine, do.object_name as locked_object,id1, id2, lmode, request, gv$lock.type
FROM gv$lock join gv$session on gv$lock.sid=gv$session.sid and gv$lock.inst_id=gv$session.inst_id
join gv$locked_object lo on gv$lock.SID = lo.SESSION_ID and gv$lock.inst_id=lo.inst_id
join dba_objects do on lo.OBJECT_ID = do.OBJECT_ID 
WHERE (id1, id2, gv$lock.type) IN (
  SELECT id1, id2, type FROM gv$lock WHERE request>0)
ORDER BY id1, request;


select 'alter system kill session ' || '''' || sid || ',' || serial# ||',@'|| inst_id || '''' || ' immediate;' from gv$session where sid='&sid' and serial#='&serial#';

SQL History :
==============

set lines 1000 pages 9999
COL instance_number FOR 9999 HEA 'Inst';
COL end_time HEA 'End Time';
COL plan_hash_value HEA 'Plan|Hash Value';
COL executions_total FOR 999,999 HEA 'Execs|Total';
COL rows_per_exec HEA 'Rows Per Exec';
COL et_secs_per_exec HEA 'Elap Secs|Per Exec';
COL cpu_secs_per_exec HEA 'CPU Secs|Per Exec';
COL io_secs_per_exec HEA 'IO Secs|Per Exec';
COL cl_secs_per_exec HEA 'Clus Secs|Per Exec';
COL ap_secs_per_exec HEA 'App Secs|Per Exec';
COL cc_secs_per_exec HEA 'Conc Secs|Per Exec';
COL pl_secs_per_exec HEA 'PLSQL Secs|Per Exec';
COL ja_secs_per_exec HEA 'Java Secs|Per Exec';
SELECT 'gv$dba_hist_sqlstat' source,h.instance_number,
       TO_CHAR(CAST(s.begin_interval_time AS DATE), 'DD-MM-YYYY HH24:MI') snap_time,
       TO_CHAR(CAST(s.end_interval_time AS DATE), 'DD-MM-YYYY HH24:MI') end_time,
       h.sql_id,
       h.plan_hash_value, 
       h.executions_total,
       TO_CHAR(ROUND(h.rows_processed_total / h.executions_total), '999,999,999,999') rows_per_exec,
       TO_CHAR(ROUND(h.elapsed_time_total / h.executions_total / 1e6, 3), '999,990.000') et_secs_per_exec,
       TO_CHAR(ROUND(h.cpu_time_total / h.executions_total / 1e6, 3), '999,990.000') cpu_secs_per_exec,
       TO_CHAR(ROUND(h.iowait_total / h.executions_total / 1e6, 3), '999,990.000') io_secs_per_exec,
       TO_CHAR(ROUND(h.clwait_total / h.executions_total / 1e6, 3), '999,990.000') cl_secs_per_exec,
       TO_CHAR(ROUND(h.apwait_total / h.executions_total / 1e6, 3), '999,990.000') ap_secs_per_exec,
       TO_CHAR(ROUND(h.ccwait_total / h.executions_total / 1e6, 3), '999,990.000') cc_secs_per_exec,
       TO_CHAR(ROUND(h.plsexec_time_total / h.executions_total / 1e6, 3), '999,990.000') pl_secs_per_exec,
       TO_CHAR(ROUND(h.javexec_time_total / h.executions_total / 1e6, 3), '999,990.000') ja_secs_per_exec
  FROM dba_hist_sqlstat h, 
       dba_hist_snapshot s
 WHERE h.sql_id = '&sql_id'
   AND h.executions_total > 0 
   AND s.snap_id = h.snap_id
   AND s.dbid = h.dbid
   AND s.instance_number = h.instance_number
UNION ALL  
SELECT 'gv$sqlarea_plan_hash' source,h.inst_id, 
       TO_CHAR(sysdate, 'DD-MM-YYYY HH24:MI') snap_time,
       TO_CHAR(sysdate, 'DD-MM-YYYY HH24:MI') end_time,
       h.sql_id,
       h.plan_hash_value, 
       h.executions,
       TO_CHAR(ROUND(h.rows_processed / h.executions), '999,999,999,999') rows_per_exec,
       TO_CHAR(ROUND(h.elapsed_time / h.executions / 1e6, 3), '999,990.000') et_secs_per_exec,
       TO_CHAR(ROUND(h.cpu_time / h.executions / 1e6, 3), '999,990.000') cpu_secs_per_exec,
       TO_CHAR(ROUND(h.USER_IO_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') io_secs_per_exec,
       TO_CHAR(ROUND(h.CLUSTER_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') cl_secs_per_exec,
       TO_CHAR(ROUND(h.APPLICATION_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') ap_secs_per_exec,
       TO_CHAR(ROUND(h.CLUSTER_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') cc_secs_per_exec,
       TO_CHAR(ROUND(h.PLSQL_EXEC_TIME / h.executions / 1e6, 3), '999,990.000') pl_secs_per_exec,
       TO_CHAR(ROUND(h.JAVA_EXEC_TIME / h.executions / 1e6, 3), '999,990.000') ja_secs_per_exec
  FROM gv$sqlarea_plan_hash h 
 WHERE h.sql_id = '&sql_id'
   AND h.executions > 0 
order by source ;

Find Force Matching Signature :
===============================
col exact_matching_signature for 99999999999999999999999999
col sql_text for a50
set long 20000
set  lines 750 pages 9999
select sql_id, exact_matching_signature, force_matching_signature, SQL_TEXT from v$sqlarea where sql_id='&sql_id';
UNION ALL
select sql_id,force_matching_signature,SQL_TEXT from dba_hist_sqltext where sql_id='&sql_id'
/

-- If you want to find Bind variable for SQL_ID

col VALUE_STRING for a50  
SELECT NAME,POSITION,DATATYPE_STRING,VALUE_STRING FROM gv$sql_bind_capture WHERE sql_id='&sql_id';


SQL Plan Flip :
===============
set lines 1000 pages 9999
COL instance_number FOR 9999 HEA 'Inst';
COL end_time HEA 'End Time';
COL plan_hash_value HEA 'Plan|Hash Value';
COL executions_total FOR 999,999 HEA 'Execs|Total';
COL rows_per_exec HEA 'Rows Per Exec';
COL et_secs_per_exec HEA 'Elap Secs|Per Exec';
COL cpu_secs_per_exec HEA 'CPU Secs|Per Exec';
COL io_secs_per_exec HEA 'IO Secs|Per Exec';
COL cl_secs_per_exec HEA 'Clus Secs|Per Exec';
COL ap_secs_per_exec HEA 'App Secs|Per Exec';
COL cc_secs_per_exec HEA 'Conc Secs|Per Exec';
COL pl_secs_per_exec HEA 'PLSQL Secs|Per Exec';
COL ja_secs_per_exec HEA 'Java Secs|Per Exec';
SELECT 'gv$dba_hist_sqlstat' source,h.instance_number,
       TO_CHAR(CAST(s.begin_interval_time AS DATE), 'DD-MM-YYYY HH24:MI') snap_time,
       TO_CHAR(CAST(s.end_interval_time AS DATE), 'DD-MM-YYYY HH24:MI') end_time,
       h.sql_id,
       h.plan_hash_value, 
       h.executions_total,
       TO_CHAR(ROUND(h.rows_processed_total / h.executions_total), '999,999,999,999') rows_per_exec,
       TO_CHAR(ROUND(h.elapsed_time_total / h.executions_total / 1e6, 3), '999,990.000') et_secs_per_exec,
       TO_CHAR(ROUND(h.cpu_time_total / h.executions_total / 1e6, 3), '999,990.000') cpu_secs_per_exec,
       TO_CHAR(ROUND(h.iowait_total / h.executions_total / 1e6, 3), '999,990.000') io_secs_per_exec,
       TO_CHAR(ROUND(h.clwait_total / h.executions_total / 1e6, 3), '999,990.000') cl_secs_per_exec,
       TO_CHAR(ROUND(h.apwait_total / h.executions_total / 1e6, 3), '999,990.000') ap_secs_per_exec,
       TO_CHAR(ROUND(h.ccwait_total / h.executions_total / 1e6, 3), '999,990.000') cc_secs_per_exec,
       TO_CHAR(ROUND(h.plsexec_time_total / h.executions_total / 1e6, 3), '999,990.000') pl_secs_per_exec,
       TO_CHAR(ROUND(h.javexec_time_total / h.executions_total / 1e6, 3), '999,990.000') ja_secs_per_exec
  FROM dba_hist_sqlstat h, 
       dba_hist_snapshot s
 WHERE h.sql_id = '&sql_id'
   AND h.executions_total > 0 and ROUND(h.elapsed_time_total / h.executions_total / 1e6, 3) > 20
   AND s.snap_id = h.snap_id
   AND s.dbid = h.dbid
   AND s.instance_number = h.instance_number
UNION ALL  
SELECT 'gv$sqlarea_plan_hash' source,h.inst_id, 
       TO_CHAR(sysdate, 'DD-MM-YYYY HH24:MI') snap_time,
       TO_CHAR(sysdate, 'DD-MM-YYYY HH24:MI') end_time,
       h.sql_id,
       h.plan_hash_value, 
       h.executions,
       TO_CHAR(ROUND(h.rows_processed / h.executions), '999,999,999,999') rows_per_exec,
       TO_CHAR(ROUND(h.elapsed_time / h.executions / 1e6, 3), '999,990.000') et_secs_per_exec,
       TO_CHAR(ROUND(h.cpu_time / h.executions / 1e6, 3), '999,990.000') cpu_secs_per_exec,
       TO_CHAR(ROUND(h.USER_IO_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') io_secs_per_exec,
       TO_CHAR(ROUND(h.CLUSTER_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') cl_secs_per_exec,
       TO_CHAR(ROUND(h.APPLICATION_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') ap_secs_per_exec,
       TO_CHAR(ROUND(h.CLUSTER_WAIT_TIME / h.executions / 1e6, 3), '999,990.000') cc_secs_per_exec,
       TO_CHAR(ROUND(h.PLSQL_EXEC_TIME / h.executions / 1e6, 3), '999,990.000') pl_secs_per_exec,
       TO_CHAR(ROUND(h.JAVA_EXEC_TIME / h.executions / 1e6, 3), '999,990.000') ja_secs_per_exec
  FROM gv$sqlarea_plan_hash h 
 WHERE h.sql_id = '&sql_id' -- and ROUND(h.elapsed_time / h.executions / 1e6, 3) > 20
   AND h.executions > 0 
order by SOURCE,SNAP_TIME ;


Find Stale Stats and Statistics details  :
===========================================

exec DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO;
select OWNER,TABLE_NAME,LAST_ANALYZED,STALE_STATS from DBA_TAB_STATISTICS where STALE_STATS='YES' and OWNER='&owner;
Select DBMS_STATS.Get_Prefs('GRANULARITY') From Dual;

DBMS_STATS.GET_PREFS('GRANULARITY')
--------------------------------------------------------------------------------
GLOBAL

SELECT dbms_stats.get_prefs('GRANULARITY','XXQBE_FDW_TGT_NAO','WC_AGGREGATED_DATAMART_NAO_F') "GRANULARITY" FROM dual;

GRANULARITY
--------------------------------------------------------------------------------
GLOBAL

*** statistics of objects of a specific sql id 

set lines 300 set pages 300
col table_name for a40
col owner for a30 
select distinct owner, table_name, STALE_STATS, last_analyzed, stattype_locked
  from dba_tab_statistics
  where (owner, table_name) in
  (select distinct owner, table_name
          from dba_tables
          where ( table_name)
          in ( select object_name
                  from gv$sql_plan
                  where upper(sql_id) = upper('&sql_id') and object_name is not null));
  --and STALE_STATS='YES'
/

PIN Optimal Plan :
==================

@coe_xfr_sql_profile.sql <sql_id> <plan_hash_value> -- to create SQL profile
The coe_xfr_sql_profile.sql script would create another sql file, which should be run to create manual sql profile for the sql 
The new sql file created.


ls -ltr coe_xfr_sql_profile_<sql_id>_<plan_hash_value>.sql
cat coe_xfr_sql_profile_<sql_id>_<plan_hash_value>.sql

@coe_xfr_sql_profile_<sql_id>_<plan_hash_value>.sql

To check if the profile is getting used or not :

select name from dba_sql_profiles;
select NAME,CREATED,LAST_MODIFIED,TYPE,STATUS,FORCE_MATCHING from dba_sql_profiles where NAME like '%&SQL_ID%';
select NAME,CREATED,LAST_MODIFIED,TYPE,STATUS,FORCE_MATCHING from dba_sql_profiles where upper(SQL_TEXT) like '%&SQL_TEXT%';

set lines 200 pages 200
col SQL_TEXT for a50
col CREATED for a20
col LAST_EXECUTED for a20
col PLAN_NAME for a40
col SQL_HANDLE for a20
select substr(sql_text,1,90) sql_text,PLAN_NAME,SQL_HANDLE,CREATED,LAST_EXECUTED,ENABLED,ACCEPTED,ELAPSED_TIME,EXECUTIONS from dba_sql_plan_baselines;

select SQL_ID, CHILD_NUMBER, PLAN_HASH_VALUE, SQL_PROFILE FROM V$SQL where sql_id='&SQL_ID';
select * from table(dbms_xplan.display_cursor('15dvhtuf0fzhh',null,'ADVANCED ALLSTATS LAST'));

Please verify is it using new PLAN_HASH_VALUE. Please note if new plan is not using, then flush the HASH VALUE to ensure the new plan is used, then have the apps team restart the process.

Flushing a Single SQL Statement from Library Cache (Only if required) :

select ADDRESS, HASH_VALUE from V$SQLAREA where SQL_ID like '&sql_id';
ADDRESS          HASH_VALUE
---------------- ----------
00000000A2D6DEE8 3174173062

exec DBMS_SHARED_POOL.PURGE ('&ADDRESS, &HASH_VALUE', 'C');
select ADDRESS, HASH_VALUE from V$SQLAREA where SQL_ID like '&sql_id';
select 'exec DBMS_SHARED_POOL.PURGE ('''||ADDRESS||', '|| HASH_VALUE||''',''C'');' from V$SQLAREA where PLAN_HASH_VALUE = '226324416';
select 'exec DBMS_SHARED_POOL.PURGE ('''||ADDRESS||', '|| HASH_VALUE||''',''C'');' from V$SQLAREA where SQL_ID like '8ycabihre66ab%';


Useful scripts related to number of executions of sql_id in Oracle Database :
==============================================================================
https://expertoracle.com/2022/11/26/useful-scripts-related-to-number-of-executions-of-sql_id-in-oracle-database/

To find the total number of executions for a specific SQL_ID:
-------------------------------------------------------------
SELECT sql_id, count(*)
FROM v$sql
WHERE sql_id = '&sql_id' -- enter the specific SQL_ID
GROUP BY sql_id;

To find the total number of executions for a specific SQL_ID in the last hour:
------------------------------------------------------------------------------
SELECT sql_id, count(*)
FROM v$sql
WHERE sql_id = '&sql_id' -- enter the specific SQL_ID
AND last_active_time > SYSDATE - (1/24)
GROUP BY sql_id;

To find the total number of executions and average elapsed time for a specific SQL_ID:
--------------------------------------------------------------------------------------
SELECT sql_id, count(*), ROUND(AVG(elapsed_time/1000000),2) "Avg Elapsed Time (s)"
FROM v$sql
WHERE sql_id = '&sql_id' -- enter the specific SQL_ID
GROUP BY sql_id;

To find the total number of executions for a specific SQL_ID for a specific period of time:
-------------------------------------------------------------------------------------------
SELECT sql_id, count(*)
FROM v$sql
WHERE sql_id = '&sql_id' -- enter the specific SQL_ID
AND last_active_time BETWEEN '&start_date' AND '&end_date' -- enter the start and end date of the period in the format 'yyyy-mm-dd hh24:mi:ss'
GROUP BY sql_id;

Queries based upon dba_hist_SQLSTAT AND dba_hist_snapshot to see historical data:
---------------------------------------------------------------------------------
select a.instance_number inst_id, a.snap_id,a.plan_hash_value, 
to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, 
abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour
from (end_interval_time-begin_interval_time))*60 + extract(day
from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) 
"avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='&sql_id' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;

SELECT SQL_ID,
COUNT(SQL_ID) as "Executions",
ROUND(AVG(ELAPSED_TIME_DELTA)/1000000,2) as "Avg Elapsed Time (s)",
ROUND(AVG(CPU_TIME_DELTA)/1000000,2) as "Avg CPU Time (s)",
ROUND(AVG(BUFFER_GETS_DELTA),2) as "Avg Buffer Gets",
ROUND(AVG(DISK_READS_DELTA),2) as "Avg Disk Reads",
ROUND(AVG(EXECUTIONS_DELTA),2) as "Avg Executions"
FROM dba_hist_SQLSTAT
WHERE SQL_ID = '&sql_id' -- enter the specific SQL_ID
AND SNAP_ID BETWEEN (SELECT MIN(snap_id) FROM dba_hist_snapshot WHERE BEGIN_INTERVAL_TIME > '&start_date') AND (SELECT MAX(snap_id) FROM dba_hist_snapshot WHERE END_INTERVAL_TIME < '&end_date')
GROUP BY SQL_ID;

select INSTANCE_NUMBER, module, action, program, session_id, to_char(sample_time, 'yyyy-mm-dd hh24:mi:ss')
from dba_hist_active_sess_history
where sample_time between to_date('2025/01/14 00:00:00','YYYY/MM/DD HH24:MI:SS') and to_date('2025/01/15 23:59:00','YYYY/MM/DD HH24:MI:SS')
and sql_id = '&SQL_ID'
order by sample_time;
 

select ss.snap_id, ss.instance_number node, begin_interval_time, sql_id, plan_hash_value,
nvl(executions_delta,0) execs,
(elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime,
(buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio,
s.ROWS_PROCESSED_TOTAL "Total Rows Processed"
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = '&sql_id'
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0 order by 1, 2, 3;


SET pages 50 lines 220 
SELECT stat.sql_id,
       plan_hash_value,
       rpad(stat.parsing_schema_name, 10) "schema",
       elapsed_time_total/1000000/60 "minutes",
       round(stat.elapsed_time_total/1000000/60/60, 1) "Hours",
       elapsed_time_delta,
       disk_reads_delta,
       stat.executions_total,
       to_char(ss.BEGIN_INTERVAL_TIME, 'dd-mm-yy hh24:mi:ss') "BeginTime",
       to_char(ss.end_interval_time, 'dd-mm-yy hh24:mi:ss') "EndTime",
       rpad(txt.sql_text, 40) text,ss.snap_id
FROM dba_hist_sqlstat stat,
     dba_hist_sqltext txt,
     dba_hist_snapshot ss
WHERE stat.sql_id = txt.sql_id
  AND stat.dbid = txt.dbid
  AND ss.dbid = stat.dbid
  AND ss.instance_number = stat.instance_number
  AND stat.snap_id = ss.snap_id
  AND parsing_schema_name NOT LIKE 'sys%'
  AND ss.begin_interval_time >= sysdate-5
  AND stat.elapsed_time_total/1000000 > 1 
--and sql_text like '%TAB_NAME%'
--and sql_text like '%TAB_NAME%'
--and to_char(ss.end_interval_time,'dd-mm-yy')='18-06-17'
and stat.sql_id='&SQL_ID';

select sql_id, child_number, plan_hash_value plan_hash, executions execs,(elapsed_time/1000000)/decode(nvl(executions,0),0,1,executions) avg_etime,
buffer_gets/decode(nvl(executions,0),0,1,executions) avg_lio,sql_text from gv$sql s where sql_id='gf55p40w2yjx3';

alter session set nls_date_format='YYYY/MM/DD HH24:MI:SS';
alter session set nls_timestamp_format='YYYY/MM/DD HH24:MI:SS';

select sql_id,
starting_time,
end_time,
(EXTRACT(HOUR FROM run_time) * 3600
+ EXTRACT(MINUTE FROM run_time) * 60
+ EXTRACT(SECOND FROM run_time)) run_time_sec,
READ_IO_BYTES,
PGA_ALLOCATED PGA_ALLOCATED_BYTES,
TEMP_ALLOCATED TEMP_ALLOCATED_BYTES
from (
select
sql_id,
max(sample_time - sql_exec_start) run_time,
max(sample_time) end_time,
sql_exec_start starting_time,
sum(DELTA_READ_IO_BYTES) READ_IO_BYTES,
sum(DELTA_PGA) PGA_ALLOCATED,
sum(DELTA_TEMP) TEMP_ALLOCATED
from
(
select sql_id,
sample_time,
sql_exec_start,
DELTA_READ_IO_BYTES,
sql_exec_id,
greatest(PGA_ALLOCATED - first_value(PGA_ALLOCATED) over (partition by sql_id,sql_exec_id order by sample_time rows 1 preceding),0) DELTA_PGA,
greatest(TEMP_SPACE_ALLOCATED - first_value(TEMP_SPACE_ALLOCATED) over (partition by sql_id,sql_exec_id order by sample_time rows 1 preceding),0) DELTA_TEMP
from
dba_hist_active_sess_history
where
sample_time >= to_date ('2017/02/22 00:00:00','YYYY/MM/DD HH24:MI:SS')
and sample_time < to_date ('2017/02/22 16:10:00','YYYY/MM/DD HH24:MI:SS')
and sql_exec_start is not null
and IS_SQLID_CURRENT='Y'
)
group by sql_id,SQL_EXEC_ID,sql_exec_start
order by sql_id
)
where sql_id = '&SQL_ID'
order by end_time desc;

Find Fragmentation:
===================
*** Table Fragmentation

select 
   table_name,round((blocks*8),2) "size (kb)" , 
   round((num_rows*avg_row_len/1024),2) "actual_data (kb)",
   (round((blocks*8),2) - round((num_rows*avg_row_len/1024),2)) "wasted_space (kb)"
from 
   dba_tables
where  owner='&OWNER' and table_name='&TABLE_NAME' and 
   (round((blocks*8),2) > round((num_rows*avg_row_len/1024),2))
order by 4 desc;

De-Fragmentation :
==================

*** There are many methods.

Option 1: Shrink command

alter table  enable row movement;
/*
Using the enable row movement clause can reduce the clustering_factor for a primary access index, causing excessive I/O.  Oracle introduced the sorted gash cluster as a way to keep an index in-order with the table rows, a technique that greatly reduces I/O for common queries. 
Beware that using "enable row movement" can cause Oracle to move rows to discontinuous data blocks, causing a performance problem.  Remember, the physical placement of rows on data blocks can still make a huge difference in query performance. 
*/
alter table  shrink space compact;
alter table  shrink space cascade;

http://www.dba-oracle.com/t_enable_row_movement.htm

Option 2: Table move

Alter table move - The alter table xxx move command moves rows down into un-used space and adjusts the HWM but does not adjust the segments extents, and the table size remains the same.  The alter table move syntax also preserves the index and constraint definitions.

ALTER TABLE <table_name>  MOVE;

Option 3: EXPORT / IMPORT

** EXPORT
** DROP ALL RESPECTIVE OBJECTS
** IMPORT FROM EXPORT BACKUP


Option 4: EXPORT / IMPORT WITH TABLE_EXISTS_ACTION=REPLACE

** EXPORT
** IMPORT USING TABLE_EXISTS_ACTION=REPLACE

CPU usage is high :
====================

SELECT a.username, a.osuser, a.program, b.spid,b.pga_used_mem/1024/1024 "PGA USED (MB)", a.sid, a.serial# ,a.module,a.logon_time,a.terminal 
FROM v$session a, v$process b WHERE a.paddr = b.addr order by b.pga_used_mem desc;

Top 10 CPU consuming Session in Oracle :
---------------------------------------
set lines 200 pages 200
col program form a30 heading "Program"
col CPUMins form 99990 heading "CPU in Mins"
select rownum as rank, a.*
from (
SELECT v.sid,sess.Serial# ,program, v.value / (100 * 60) CPUMins
FROM gv$statname s , gv$sesstat v, gv$session sess
WHERE s.name = 'CPU used by this session'
and sess.sid = v.sid
and v.statistic#=s.statistic#
and v.value>0
ORDER BY v.value DESC) a
where rownum < 11;

select B.SQL_FULLTEXT from  V$SQL B WHERE B.SQL_ID='&SQL_ID';
select B.SQL_TEXT from dba_hist_sqltext B WHERE B.SQL_ID='&SQL_ID';

Top CPU Consuming Session in last 10 min : HIGH CPU / High CPU / high CPU
-------------------------------------------

select * from
(
select session_id, session_serial#, count(*)
from gv$active_session_history
where session_state= 'ON CPU' and
sample_time >= sysdate - interval '120' minute
group by session_id, session_serial#
order by count(*) desc
);

select event, count(1)
from gv$active_session_history
where
    sample_time between to_date('12122024 22:00:00', 'ddmmyyyy hh24:mi:ss')
                and     to_date('12122024 23:00:00', 'ddmmyyyy hh24:mi:ss')
group by event
order by 2 desc;
EVENT                                  COUNT(1)
------------------------------------ ----------
library cache lock                       350174
library cache: mutex X                    54474
cursor: pin S wait on X                   10896
                                           2964

select sql_id, count(1)
from gv$active_session_history
where
    sample_time between to_date('14012024 20:00:00', 'ddmmyyyy hh24:mi:ss')
                and     to_date('15012024 11:00:00', 'ddmmyyyy hh24:mi:ss')
and event in
 ('library cache lock','library cache: mutex X','cursor: pin S wait on X')
group by sql_id
order by 2 desc;
 
SQL_ID            COUNT(1)
----------------- --------
6tcs65pchhp71       147902
9mqzzppbpa64j         7373
                         3  
						 
select sql_id, count(1)
from gv$active_session_history
where
    sample_time between to_date('14012024 20:00:00', 'ddmmyyyy hh24:mi:ss')
                and     to_date('15012024 11:00:00', 'ddmmyyyy hh24:mi:ss')
and sql_id='&SQL_ID' group by sql_id
order by 2 desc;
						 

						 
SQL id consuming more CPU in Oracle  :
-------------------------------------
set lines 200 pages 200
col program form a27 heading "Program"
col cpu_usage_sec form 99999 heading "CPUinSeconds"
col MODULE for a28
col OSUSER for a10
col USERNAME for a16
col OSPID for a06 heading "OS PID"
col SID for 99999
col SERIAL# for 999999
col SQL_ID for a15
col MACHINE a9
select * from (
select ss.INST_ID,p.spid "ospid",
(se.SID),ss.serial#,ss.SQL_ID,ss.username,substr(ss.program,1,30) "program",
ss.module,ss.osuser,ss.MACHINE,ss.status,
se.VALUE/100 cpu_usage_sec
from gv$session ss,gv$sesstat se,
gv$statname sn,gv$process p
where
se.STATISTIC# = sn.STATISTIC#
and NAME like '%CPU used by this session%'
and se.SID = ss.SID
-- and ss.username !='SYS'
and ss.status='ACTIVE'
and ss.username is not null
and ss.paddr=p.addr and value > 0
order by se.VALUE desc);

7b5w34atn8q1h  497wh6n7hu14f  ay44jj6hphbuz

select B.SQL_FULLTEXT from V$SQL B WHERE B.SQL_ID='&SQL_ID';
select B.SQL_TEXT from dba_hist_sqltext B WHERE B.SQL_ID='&SQL_ID';
select sql_id from dba_hist_sqltext where SQL_TEXT like '%v$logmnr_contents%';

SQL Text top consuming CPU in Oracle :
-------------------------------------
col cpu_usage_sec form 99990 heading "CPU in Seconds"
select * from (
select
(se.SID),substr(q.sql_text,80),ss.module,ss.status,se.VALUE/100 cpu_usage_sec
from v$session ss,v$sesstat se,
v$statname sn, v$process p, v$sql q
where
se.STATISTIC# = sn.STATISTIC#
AND ss.sql_address = q.address
AND ss.sql_hash_value = q.hash_value
and NAME like '%CPU used by this session%'
and se.SID = ss.SID
and ss.username !='SYS'
and ss.status='ACTIVE'
and ss.username is not null
and ss.paddr=p.addr and value > 0
order by se.VALUE desc);

select snap_id,TO_CHAR(BEGIN_INTERVAL_TIME, 'DD-MM-YYYY HH24:MI') snap_time,TO_CHAR(END_INTERVAL_TIME, 'DD-MM-YYYY HH24:MI') snap_time 
from dba_hist_snapshot where BEGIN_INTERVAL_TIME > sysdate -5 order by snap_id;
select * from DBA_HIST_SYSMETRIC_SUMMARY where snap_id=&snap_id and metric_name in ('Host CPU Utilization (%)','I/O Megabytes per Second','I/O Requests per Second','Total PGA Allocated');


SQL Tracing :
=============
set linesize 750 pages 9999
column box format a30
column spid format a10
column username format a30 
column program format a30
column os_user format a20
col LOGON_TIME for a20  

select b.inst_id,b.sid,b.serial#,a.spid, substr(b.machine,1,30) box,to_char (b.logon_time, 'dd-mon-yyyy hh24:mi:ss') logon_time,
 substr(b.username,1,30) username,
 substr(b.osuser,1,20) os_user,
 substr(b.program,1,30) program,status,b.last_call_et AS last_call_et_secs,b.sql_id 
 from gv$session b,gv$process a 
 where b.paddr = a.addr 
 and a.inst_id = b.inst_id  
 and type='USER' and b.username='&username'
-- and b.status='ACTIVE'
-- and b.status='INACTIVE'
 order by logon_time;
 
begin
  dbms_monitor.session_trace_enable (
    session_id => <SID>, 
    serial_num => <serial#>, 
    waits      => true, 
    binds      => true
    plan_stat  => 'all_executions');
end;
/
SQL> alter session set container=GEOBF1;
BEGIN
DBMS_MONITOR.CLIENT_ID_TRACE_ENABLE(
 client_id => 'SGOLI' ,
 waits => true ,
 binds => true );
END;
/
EXECUTE DBMS_MONITOR.CLIENT_ID_TRACE_DISABLE(client_id =>'KMONDAL');


exec DBMS_MONITOR.CLIENT_ID_TRACE_ENABLE('this is a test',true,true);

select
   r.value                                ||'/diag/rdbms/'||
   sys_context('USERENV','DB_NAME')       ||'/'||
   sys_context('USERENV','INSTANCE_NAME') ||'/trace/'||
   sys_context('USERENV','DB_NAME')       ||'_ora_'||p.spid||'.trc'
   as tracefile_name
from v$session s, v$parameter r, v$process p
where r.name = 'diagnostic_dest'
and s.sid = &1
and p.addr = s.paddr;

begin
  dbms_monitor.session_trace_disable (
    session_id => <SID>, 
    serial_num => <serial#>);
end;
/
select * from table(dbms_xplan.display_cursor('8f8305w47fg3u', 0));

##### SQL Tuning Advisor /ASH /AWR:
===================================
@$ORACLE_HOME/rdbms/admin/awrrpti.sql
@$ORACLE_HOME/rdbms/admin/awrrpt.sql
@$ORACLE_HOME/rdbms/admin/awrddrpt.sql        => Linux  
@?/rdbms/admin/awrgrpt.sql 					  => Global AWR report Linux   
@?/rdbms/admin/awrrpt.sql                     => Windows

@$ORACLE_HOME/rdbms/admin/sqltrpt.sql		  => Linux
@?/rdbms/admin/sqltrpt.sql                    => Windows
@$ORACLE_HOME/rdbms/admin/utlrp.sql
@?/rdbms/admin/ashrpt.sql
@?/rdbms/admin/ashrpti.sql
-6:40
@$ORACLE_HOME/rdbms/admin/spreport.sql  ==> Statspack
132121 132124
@$ORACLE_HOME/rdbms/admin/sppurge  ==> Statspack purge
4892
5581
05/28/22 01:00:00
select s.snap_id
     , to_char(s.snap_time,' dd Mon YYYY HH24:mi:ss')    snap_date
     , s.baseline
     , s.snap_level                                      "level"
     , di.host_name                                      host_name
     , s.ucomment
  from stats$snapshot s
     , stats$database_instance di
 where di.startup_time = s.startup_time
 order by db_name, instance_name, snap_id;

cellcli -e "LIST griddisk attributes name,asmmodestatus,redundancystatus,rebalancetask"


rman target sys/phoebe1899@stby

Manually sql tunning advisor :
-------------------------------
SET SERVEROUTPUT ON
declare
stmt_task VARCHAR2(40);
begin
stmt_task := DBMS_SQLTUNE.CREATE_TUNING_TASK(sql_id => 'cky05vpq4z3ra');
DBMS_OUTPUT.put_line('task_id: ' || stmt_task );
end;
/

Execute dbms_sqltune.Execute_tuning_task (task_name => 'cky05vpq4z3ra_sql_tuning_task');
select status from dba_advisor_log where task_name='cky05vpq4z3ra_sql_tuning_task';

set long 65536
set longchunksize 65536
set linesize 100
select dbms_sqltune.report_tuning_task('TEST_sql_tuning_task') from dual;


DECLARE
l_sql_tune_task_id VARCHAR2(100);
BEGIN
l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
sql_id => 'cky05vpq4z3ra',
scope => DBMS_SQLTUNE.scope_comprehensive,
time_limit => 500,
task_name => 'cky05vpq4z3ra_tuning_task11',
description => 'Tuning task1 for statement cky05vpq4z3ra');
DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
END;
/
 
EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => 'cky05vpq4z3ra_tuning_task11');
 
set long 65536
set longchunksize 65536
set linesize 100
select dbms_sqltune.report_tuning_task('cky05vpq4z3ra_tuning_task11') from dual;


From AWR :
===========
select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='&sql_id' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number; 

select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi'),to_char(end_interval_time,'dd-mon-yy hh24:mi') from 
dba_hist_SQLSTAT a, dba_hist_snapshot b where sql_id='&sql_id' and a.snap_id=b.snap_id and a.instance_number=b.instance_number;

Create tuning task :
----------------------
DECLARE
  l_sql_tune_task_id  VARCHAR2(100);
BEGIN
  l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
                          begin_snap  => 15307,
                          end_snap    => 15308,
                          sql_id      => '1wsnyp54jmf4c',
                          scope       => DBMS_SQLTUNE.scope_comprehensive,
                          time_limit  => 60,
                          task_name   => '1wsnyp54jmf4c_AWR_tuning_task',
                          description => 'Tuning task for statement 1wsnyp54jmf4c  in AWR');
  DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
END;
/

EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => '1wsnyp54jmf4c_AWR_tuning_task');



SELECT TASK_NAME, STATUS FROM DBA_ADVISOR_LOG WHERE TASK_NAME='1wsnyp54jmf4c_AWR_tuning_task';

SET LONG 10000000;
SET PAGESIZE 100000000
SET LINESIZE 200
SELECT DBMS_SQLTUNE.report_tuning_task('1wsnyp54jmf4c_AWR_tuning_task') AS recommendations FROM dual;



 
 DBA_SQLTUNE_STATISTICS, DBA_SQLTUNE_BINDS, and DBA_SQLTUNE_PLANS

Resent past :
-------------
SELECT  du.username,
        s.sql_text, 
        MAX(ash.sample_time) AS last_access ,
        sp.object_owner ,
        sp.object_name ,
        sp.object_alias as aliased_as ,
        sp.object_type ,
        COUNT(*) AS access_count 
FROM    v$active_session_history ash
        JOIN v$sql s ON ash.force_matching_signature = s.force_matching_signature
        LEFT JOIN v$sql_plan sp ON s.sql_id = sp.sql_id
        JOIN DBA_USERS du ON ash.user_id = du.USER_ID
WHERE   ash.session_type = 'FOREGROUND' 
        AND ash.SQL_ID IS NOT NULL
        AND sp.object_name IS NOT NULL
        AND ash.user_id <> 0
GROUP BY du.username, 
        s.sql_text, 
        sp.object_owner, 
        sp.object_name, 
        sp.object_alias, 
        sp.object_type 
ORDER BY 3 DESC;


SELECT  distinct sh.sql_id, sh.blocking_session,sh.blocking_session_serial#,
sh.user_id,s.sql_text,sh.module
FROM  V$ACTIVE_SESSION_HISTORY sh, v$sql s
where sh.sql_id=s.sql_id
and blocking_session is not null
and sh.user_id <> 0
and sh.sample_time between to_date('28-05-2022 00:45', 'dd-mm-yyyy hh24:mi')
and to_date('28-05-2022 01:15', 'dd-mm-yyyy hh24:mi');


Query run between specific time:
=================================
SELECT sql_id, first_load_time, last_active_time, sql_text FROM v$sqlarea
WHERE last_active_time BETWEEN TO_DATE ('19/10/2012 14:00:00','DD/MM/YYYY HH24:MI:SS') AND TO_DATE ('19/10/2012 15:00:00','DD/MM/YYYY HH24:MI:SS');

Finding query with high temp space usage using ASH views :
=========================================================
Select se.username,se.sid,sum(tu.blocks)*8192 from v$tempseg_usage tu,v$session se where tu.session_addr=se.saddr and tu.session_num=se.serial#
group by se.sid,se.username order by se.sid;

Top sql_id's that consumed PGA:
-------------------------------- 

select *
from (select instance_number, sql_id, max(pga_sum_mb) pga_max
        from (select instance_number, sample_time, sql_id, round(sum(nvl(pga_allocated, 0))/1024/1024) pga_sum_mb
                from dba_hist_active_sess_history
               where sample_time between to_timestamp('&begin_timestamp', 'yyyy/mm/dd hh24:mi') and to_timestamp('&end_timestamp', 'yyyy/mm/dd hh24:mi')
            group by instance_number, sample_time, sql_id)
       group by instance_number, sql_id
       order by pga_max desc)
where rownum <= 10;

Top sql_id's that consumed temporary segments: 
----------------------------------------------
select *
from (select instance_number, sql_id, max(temp_sum_mb) temp_max
        from (select instance_number, sample_time, sql_id, round(sum(nvl(temp_space_allocated, 0))/1024/1024) temp_sum_mb
                from dba_hist_active_sess_history
               where sample_time between to_timestamp('&begin_timestamp', 'yyyy/mm/dd hh24:mi') and to_timestamp('&end_timestamp', 'yyyy/mm/dd hh24:mi')
            group by instance_number, sample_time, sql_id)
       group by instance_number, sql_id
       order by temp_max desc)
where rownum <= 10;  

AWR report :
============
https://smarttechways.com/2019/10/04/creating-awr-report-for-pdb-database-on-12-2-oracle/
https://antognini.ch/2020/09/awr-multitenant-specific-initialization-parameters/
check if the pdb level awr is enabled or not ?
show parameter awr
By default, the database engine automatically takes snapshots in the root container only. Such snapshots cover the root container as well as all open PDBs belonging to it. From version 12.2 onward, you can control whether the database engine automatically takes also PDB-level snapshots through the dynamic initialization parameter AWR_PDB_AUTOFLUSH_ENABLED. In case you want to enable that feature, you have to carry out two operations:

Set the initialization parameter AWR_PDB_AUTOFLUSH_ENABLED to TRUE (the default value is FALSE) either in a specific PDB or, if you want to enable it for all PDBs, in the root container.
Set the snapshot interval at the PDB level.

select * from cdb_hist_wr_control;
@?/rdbms/admin/awrrpt.sql;





Memory :
========
https://dbaalikapar.wordpress.com/tag/too-many-child-cursors/
Step by step analyzing ORA-04031 unable to allocate x bytes of shared memory error in oracle


Historical PGA and total memory usage : 
alter SESSION set NLS_DATE_FORMAT = 'DD-MM-YYYY HH24:MI:SS';
SELECT sn.INSTANCE_NUMBER,
         sga.allo sga,
         pga.allo pga,
         (sga.allo + pga.allo) tot,
         TRUNC (SN.END_INTERVAL_TIME, 'mi') time
    FROM (  SELECT snap_id,
                   INSTANCE_NUMBER,
                   ROUND (SUM (bytes) / 1024 / 1024 / 1024, 3) allo
              FROM DBA_HIST_SGASTAT
          GROUP BY snap_id, INSTANCE_NUMBER) sga,
         (  SELECT snap_id,
                   INSTANCE_NUMBER,
                   ROUND (SUM (VALUE) / 1024 / 1024 / 1024, 3) allo
              FROM DBA_HIST_PGASTAT
             WHERE name = 'total PGA allocated'
          GROUP BY snap_id, INSTANCE_NUMBER) pga,
         dba_hist_snapshot sn
   WHERE     sn.snap_id = sga.snap_id and pga.allo > 75
         AND sn.INSTANCE_NUMBER = sga.INSTANCE_NUMBER
         AND sn.snap_id = pga.snap_id
         AND sn.INSTANCE_NUMBER = pga.INSTANCE_NUMBER
ORDER BY sn.snap_id DESC, sn.INSTANCE_NUMBER;

Historical shared pool free memory in each instance. We can use this query to compare when shared pool grow fast.

select HS.BEGIN_INTERVAL_TIME,ss.*
from DBA_HIST_SGASTAT ss ,dba_hist_snapshot hs
where pool=’shared pool’ and name=’free memory’
and SS.SNAP_ID=HS.SNAP_ID
and SS.INSTANCE_NUMBER=HS.INSTANCE_NUMBER
and ss.instance_number=2
–and HS.BEGIN_INTERVAL_TIME between to_date(’17-09-2019 13:00:00′,’dd-mm-yyyy hh24:mi:ss’) and to_date(’17-09-2019 15:30:00′,’dd-mm-yyyy hh24:mi:ss’)
order by ss.snap_id desc;



SET pages500 lines110 trims ON
CLEAR col
col NAME format a30
col username format a20
break ON username nodup SKIP 1

SELECT vses.username||':'||vsst.SID||','||vses.serial# username, vstt.NAME, MAX(vsst.VALUE) VALUE
FROM gv$sesstat vsst, gv$statname vstt, gv$session vses
WHERE vstt.statistic# = vsst.statistic# AND vsst.SID = vses.SID AND vstt.NAME IN
('session pga memory','session pga memory max','session uga memory','session uga memory max',
'session cursor cache count','session cursor cache hits','session stored procedure space',
'opened cursors current','opened cursors cumulative') AND vses.username IS NOT NULL
GROUP BY vses.username, vsst.SID, vses.serial#, vstt.NAME
ORDER BY vses.username, vsst.SID, vses.serial#, vstt.NAME;

select sess.username  as username
      ,sess.sid       as session_id
      ,sess.serial#   as session_serial
      ,sess.program   as session_program
      ,sess.server    as session_mode
      ,round(stat.value/1024/1024, 2) as "current_UGA_memory (in MB)"
  from gv$session    sess
      ,gv$sesstat    stat
      ,gv$statname   name
  where sess.sid        = stat.sid
    and stat.statistic# = name.statistic#
    and name.name       = 'session uga memory'
    and sess.username   = '&SCHEMA_NAME' 
    order by
    value;
	
aadbctrl.ksh -s aqprd01 -c stop


function start_db_res { 

$GRID_HOME/bin/crsctl start resource AVQMT-VIP.canaccord.com -n gsy-avqt1 -f 

} 

function stop_db_res { 

$GRID_HOME/bin/crsctl stop resource AVQDT-DATABASE-aqtst01 -f 

} 

stop_db_res :
This function calls the clusterware command to stop the database resource. Since the management VIP resource is dependent 
on the database resource, it is also stopped. 

This function is only used in script #2. 

5tBbkLGAzHmxU2LZWFlw



Customer wants to do OS patching activity and they want to stop the cluster . 
But it has been observed in the past that after stopping the crs it is getting started again. 
I have disabled the crs on first node and tried to stop the crs on test cluster on first node it has relocated the resources to other passive node

as 


cd /u02/app/oracle/admin/aqtprd01/aaa/bin

aadbctrl.ksh -s aqprd01 -c stop


alter System set SERVICE_NAMES='<CDBNAME>' SCOPE=BOTH;
        alter system register;
alter pluggable database open read write services=all;


Oracle Apps :
==============
GEt SID from request id : 

SELECT d.inst_id,a.request_id,
d.sid as Oracle_SID,
d.serial#,
d.osuser,
d.process,
d.sql_id,
c.SPID
FROM apps.fnd_concurrent_requests a,
apps.fnd_concurrent_processes b,
gv$process c,
gv$session d
WHERE a.controlling_manager = b.concurrent_process_id
AND c.pid = b.oracle_process_id
AND b.session_id=d.audsid
AND a.request_id in ('&REQUEST_ID')
AND a.phase_code='R';

Get the login page :
bash-4.2$ grep -i login $CONTEXT_FILE
<login_page oa_var="s_login_page">https://ebs.erp.qbe.com/OA_HTML/AppsLogin</login_page>
bash-4.2$

Check the cncurrant manager actual and target :

SELECT   b.user_concurrent_queue_name "Concurrent Manager", a.TARGET_NODE "Node", a.running_processes "ACTUAL Processes", a.max_processes "TARGET Processes"
   ,DECODE (b.control_code
     ,'D', 'Deactivating'
     ,'E', 'Deactivated'
     ,'N', 'Node unavai'
     ,'A', 'Activating'
     ,'X', 'Terminated'
     ,'T', 'Terminating'
     ,'V', 'Verifying'
     ,'O', 'Suspending'
     ,'P', 'Suspended'
     ,'Q', 'Resuming'
     ,'R', 'Restarting'
     ) status
  FROM apps.fnd_concurrent_queues a, apps.fnd_concurrent_queues_vl b
    WHERE a.concurrent_queue_id = b.concurrent_queue_id AND a.running_processes = a.max_processes
 ORDER BY a.max_processes DESC;
 
onnect to PDB on the DB node:
Check the permission on the DBA_JAVA_POLICY table and give permission if doesn't exists:

 

set lines 220 pages 2000
col GRANTEE format a14
col TYPE_SCHEMA format a12
col TYPE_NAME format a55
col NAME format a70
col ACTION format a29
select kind, grantee, type_schema, type_name, name, action, enabled from DBA_JAVA_POLICY where NAME='/u01/app/oracle/EQDEV1/interface/GLInterface/Gloria/inbound';
select kind, grantee, type_schema, type_name, name, action, enabled from DBA_JAVA_POLICY where NAME like '%interface/GLInterface/Gloria/inbound';

exec dbms_java.grant_permission( 'APPS', 'SYS:java.io.FilePermission','/interface/i_tnpn/GEOTEP/bank_payment_in/JPMC_TUS', 'read','write','execute');
exec dbms_java.grant_permission( 'APPS', 'SYS:java.io.FilePermission','/interface/i_tnpn/GEOTEP/bank_payment_in/CITI_TMX', 'read','write','execute');


select kind, grantee, type_schema, type_name, name, action, enabled from DBA_JAVA_POLICY where NAME='/interface/i_tnpn/GEOTEP/bank_payment_in/JPMC_TUS';
KIND     GRANTEE        TYPE_SCHEMA  TYPE_NAME                NAME                                                ACTION                        ENABLED
-------- -------------- ------------ ------------------------ --------------------------------------------------- ----------------------------- --------
GRANT    APPS           SYS          java.io.FilePermission   /interface/i_tnpn/GEOTEP/bank_payment_in/JPMC_TUS   read                          ENABLED

exec dbms_java.grant_permission( 'APPS', 'SYS:java.io.FilePermission','/interface/i_tnpn/GEOTEP/bank_payment_in/JPMC_TUS/TECHNIP/*', 'read');
exec dbms_java.grant_permission( 'APPS', 'SYS:java.io.FilePermission','/interface/i_tnpn/GEOTEP/bank_payment_in/JPMC_TUS/TECHNIP/*', 'write');
exec dbms_java.grant_permission( 'APPS', 'SYS:java.io.FilePermission','/interface/i_tnpn/GEOTEP/bank_payment_in/JPMC_TUS/TECHNIP/*', 'execute');

 
INC175445 | Incident | ServiceNow Customer Service Management Suite (service-now.com)

Hi Team,

This backup job we have recently enabled which was disabled due to Migration project. 
RMAN backup got failed as database was shut down during the reboot activity. 

We will ensure that backup should be completed before the shutting down the database .


delete backup completed before 'sysdate-5';


set pages 66
set line 132
col user_name format a20 word_wrapped
column ProgName format a25 word_wrapped
column requestId format 9999999999
column StartDate format a20 word_Wrapped
column OS_PROCESS_ID format a9
column ETime_Mins format 9999 word_Wrapped
col sid format 99999 word_Wrapped
select sess.sid,sess.serial#,oracle_process_id OS_PROCESS_ID,fusr.description user_name ,fcp.user_concurrent_program_name progName,to_char(actual_Start_date,'DD-MON-YYYY HH24:MI:SS') StartDate,
request_id RequestId,(sysdate - actual_start_date)*24*60 ETime_Mins from apps.fnd_concurrent_requests fcr,apps.fnd_concurrent_programs_tl fcp,
apps.fnd_user fusr,gv$session sess where fcp.concurrent_program_id = fcr.concurrent_program_id and fcr.program_application_id = fcp.application_id 
and fcp.language in ('US','JA','ZHS') and fcr.phase_code = 'R' and fcr.status_code = 'R' and fcr.requested_by = fusr.user_id and fcr.oracle_session_id = sess.audsid (+)
--and p.addr = sess.paddr
order by 5 DESC;


SELECT
fcr.request_id "Child Request ID",
PARENT_REQUEST_ID "Parent Request ID",
fcptl.user_concurrent_program_name"Parent Program Name",
fcr.phase_code,
fcr.status_code,
to_char(fcr.actual_start_date,'DD-MON-YYYY HH24:MI:SS') "Start Time",
round((fcr.actual_completion_date - fcr.actual_start_date)*1440,2) "Elapsed Mins"
FROM (SELECT
fcr1.request_id
FROM apps.fnd_concurrent_requests fcr1
WHERE 1=1
START WITH fcr1.a = '&Parent_request_id'
CONNECT BY PRIOR fcr1.request_id = fcr1.parent_request_id) x,
apps.fnd_concurrent_requests fcr,
apps.fnd_concurrent_programs fcp,
apps.fnd_concurrent_programs_tl fcptl
WHERE fcr.request_id = x.request_id
AND fcr.concurrent_program_id = fcp.concurrent_program_id
AND fcr.program_application_id = fcp.application_id
AND fcp.application_id = fcptl.application_id
AND fcp.concurrent_program_id = fcptl.concurrent_program_id
AND  fcr.phase_code = 'R' and fcr.status_code = 'R'
--AND fcptl.language = 'US'
ORDER BY 1;

SELECT SUBSTR(LTRIM(req.request_id),1,15) concreq,fu.user_name "Username",sw.sid sid, vsess.serial# serial#,nvl2(sysdate,(to_char(floor((sysdate-actual_start_date)*24))||' hrs  '||to_char(round (((sysdate-actual_start_date)*60*24),0)- (floor((sysdate-actual_start_date)*24)*60)) ||' mins'),null)time,SUBSTR(proc.os_process_id,1,15) SPID,vsess.sql_hash_value,vsess.module,fcp.USER_CONCURRENT_PROGRAM_NAME "Program_Name"

Laura.Nikander@pence.net:15527803023743
EXEC DBMS_MONITOR.client_id_trace_enable(client_id=>'Laura.Nikander@pence.net:15527803023743', waits=>TRUE, binds=>tRUE);


column "Percent of Total Disk Usage" justify right format 999.99
column "Space Used (MB)" justify right format 9,999,999.99
column "Total Object Size (MB)" justify right format 9,999,999.99
set linesize 150
set pages 80
set feedback off
 
select * from (select to_char(end_interval_time, 'MM/DD/YY') mydate, sum(space_used_delta) / 1024 / 1024 "Space used (MB)", avg(c.bytes) / 1024 / 1024 "Total Object Size (MB)",
round(sum(space_used_delta) / sum(c.bytes) * 100, 2) "Percent of Total Disk Usage"
from
   dba_hist_snapshot sn,
   dba_hist_seg_stat a,
   dba_objects b,
   dba_segments c
where
begin_interval_time > trunc(sysdate) - &days_back
and sn.snap_id = a.snap_id
and b.object_id = a.obj#
and b.owner = c.owner
and b.object_name = c.segment_name
and c.segment_name = '&segment_name'
group by to_char(end_interval_time, 'MM/DD/YY'))
order by to_date(mydate, 'MM/DD/YY');

https://ebs-app01-snd.dartmouth.edu:7002/console/login/LoginForm.jsp

ebs-app01-snd
/opt/admin/iam/bin/start_iam.sh -a ebs-app01-snd.dartmouth.edu



dbaascli database backup --start --level1 --dbname AGEOTEP
dbaascli database backup --dbname AGEOTEP --status --uuid 8952a75ecf0011edbceb02001702efee



exec fnd_stats.GATHER_TABLE_STATS( OWNNAME => 'GL',TABNAME=> 'GL_JE_LINES' , PARTNAME=> 'APR24' ,PERCENT => 1, DEGREE => 8 );
exec fnd_stats.GATHER_TABLE_STATS( OWNNAME => 'GL',TABNAME=> 'GL_JE_LINES' , PARTNAME=> 'MAY24' ,PERCENT => 1, DEGREE => 8 );
exec fnd_stats.GATHER_TABLE_STATS( OWNNAME => 'GL',TABNAME=> 'GL_LEDGERS' ,PERCENT => 1, DEGREE => 8 );








create user amit identified by dfa$#343WERWER ;
